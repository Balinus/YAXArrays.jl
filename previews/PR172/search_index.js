var documenterSearchIndex = {"docs":
[{"location":"howtos/yaxarrays/#The-YAXArray-Data-Type","page":"-","title":"The YAXArray Data Type","text":"","category":"section"},{"location":"howtos/yaxarrays/","page":"-","title":"-","text":"The YAXArray data type handles the ","category":"page"},{"location":"howtos/iterators/#Table-style-iteration-over-YAXArrays","page":"-","title":"Table-style iteration over YAXArrays","text":"","category":"section"},{"location":"examples/Saving and rechunking/#Saving-and-and-Rechunking-Datasets-and-YAXArrays","page":"Saving and rechunking","title":"Saving and and Rechunking Datasets and YAXArrays","text":"","category":"section"},{"location":"examples/Saving and rechunking/#Saving","page":"Saving and rechunking","title":"Saving","text":"","category":"section"},{"location":"examples/Saving and rechunking/#Saving-a-YAXArray-to-Zarr","page":"Saving and rechunking","title":"Saving a YAXArray to Zarr","text":"","category":"section"},{"location":"examples/Saving and rechunking/","page":"Saving and rechunking","title":"Saving and rechunking","text":"One can save any YAXArray using the savecube function. Simply add a path as an argument and the cube will be saved. ","category":"page"},{"location":"examples/Saving and rechunking/","page":"Saving and rechunking","title":"Saving and rechunking","text":"julia> using YAXArrays, Zarr\n\njulia> a = YAXArray(rand(10,20));\n\njulia> f = tempname();\n\njulia> savecube(a,f,driver=:zarr)\nYAXArray with the following dimensions\nDim_1               Axis with 10 Elements from 1 to 10\nDim_2               Axis with 20 Elements from 1 to 20\nTotal size: 1.56 KB","category":"page"},{"location":"examples/Saving and rechunking/","page":"Saving and rechunking","title":"Saving and rechunking","text":"If the pathname ends with \".zarr\", the driver argument can be omitted. ","category":"page"},{"location":"examples/Saving and rechunking/#Saving-a-YAXArray-to-NetCDF","page":"Saving and rechunking","title":"Saving a YAXArray to NetCDF","text":"","category":"section"},{"location":"examples/Saving and rechunking/","page":"Saving and rechunking","title":"Saving and rechunking","text":"Saving to NetCDF works exactly the same way. The driver argument can be omitted when the filename ends with \".nc\"","category":"page"},{"location":"examples/Saving and rechunking/","page":"Saving and rechunking","title":"Saving and rechunking","text":"julia> using YAXArrays, Zarr, NetCDF\n\njulia> a = YAXArray(rand(10,20));\n\njulia> f = tempname();\n\njulia> savecube(a,f,driver=:netcdf)\nYAXArray with the following dimensions\nDim_1               Axis with 10 Elements from 1 to 10\nDim_2               Axis with 20 Elements from 1 to 20\nTotal size: 1.56 KB","category":"page"},{"location":"examples/Saving and rechunking/#Saving-a-Dataset","page":"Saving and rechunking","title":"Saving a Dataset","text":"","category":"section"},{"location":"examples/Saving and rechunking/","page":"Saving and rechunking","title":"Saving and rechunking","text":"Saving Datasets can be done using the savedataset function.","category":"page"},{"location":"examples/Saving and rechunking/","page":"Saving and rechunking","title":"Saving and rechunking","text":"julia> using YAXArrays, Zarr\n\njulia> ds = Dataset(x = YAXArray(rand(10,20)), y = YAXArray(rand(10)));\n\njulia> f = tempname();\n\njulia> savedataset(ds,path=f,driver=:zarr)\nYAXArray Dataset\nDimensions: \n   Dim_2               Axis with 20 Elements from 1 to 20\n   Dim_1               Axis with 10 Elements from 1 to 10\nVariables: x y","category":"page"},{"location":"examples/Saving and rechunking/#Overwriting-a-Dataset","page":"Saving and rechunking","title":"Overwriting a Dataset","text":"","category":"section"},{"location":"examples/Saving and rechunking/","page":"Saving and rechunking","title":"Saving and rechunking","text":"If a path already exists, an error will be thrown. Set overwrite=true to delete the existing dataset","category":"page"},{"location":"examples/Saving and rechunking/","page":"Saving and rechunking","title":"Saving and rechunking","text":"julia> savedataset(ds,path=f,driver=:zarr, overwrite=true)\nYAXArray Dataset\nDimensions: \n   Dim_2               Axis with 20 Elements from 1 to 20\n   Dim_1               Axis with 10 Elements from 1 to 10\nVariables: x y","category":"page"},{"location":"examples/Saving and rechunking/#Appending-to-a-Dataset","page":"Saving and rechunking","title":"Appending to a Dataset","text":"","category":"section"},{"location":"examples/Saving and rechunking/","page":"Saving and rechunking","title":"Saving and rechunking","text":"New variables can be added to an existing dataset using the append=true keyword. ","category":"page"},{"location":"examples/Saving and rechunking/","page":"Saving and rechunking","title":"Saving and rechunking","text":"julia> ds2 = Dataset(z = YAXArray(rand(10,20,5)));\n\njulia> savedataset(ds2,path=f,backend=:zarr,append=true);\n\njulia> open_dataset(f, driver=:zarr)\nYAXArray Dataset\nDimensions: \n   Dim_2               Axis with 20 Elements from 1 to 20\n   Dim_1               Axis with 10 Elements from 1 to 10\n   Dim_3               Axis with 5 Elements from 1 to 5\nVariables: x z y ","category":"page"},{"location":"examples/Saving and rechunking/#Creating-a-Datacube-without-writing-the-actual-data","page":"Saving and rechunking","title":"Creating a Datacube without writing the actual data","text":"","category":"section"},{"location":"examples/Saving and rechunking/","page":"Saving and rechunking","title":"Saving and rechunking","text":"Sometimes one merely wants to create a datacube  \"Skeleton\" on disk and gradually fill it with data. Here we create YAXArray and write only the axis data and array metadata to disk, while no actual array data is copied:","category":"page"},{"location":"examples/Saving and rechunking/","page":"Saving and rechunking","title":"Saving and rechunking","text":"julia> using YAXArrays, Zarr\n\njulia> a = YAXArray(zeros(Union{Missing, Int32},10,20))\nYAXArray with the following dimensions\nDim_1               Axis with 10 Elements from 1 to 10\nDim_2               Axis with 20 Elements from 1 to 20\nTotal size: 800.0 bytes\n\n\njulia> f = tempname();\n\njulia> r = savecube(a,f,driver=:zarr,skeleton=true);\n\njulia> all(ismissing,r[:,:])\ntrue","category":"page"},{"location":"examples/Saving and rechunking/","page":"Saving and rechunking","title":"Saving and rechunking","text":"The skeleton argument is also available for savedataset. ","category":"page"},{"location":"examples/Saving and rechunking/#Rechunking","page":"Saving and rechunking","title":"Rechunking","text":"","category":"section"},{"location":"examples/Saving and rechunking/#Saving-a-YAXArray-with-user-defined-chunks","page":"Saving and rechunking","title":"Saving a YAXArray with user-defined chunks","text":"","category":"section"},{"location":"examples/Saving and rechunking/","page":"Saving and rechunking","title":"Saving and rechunking","text":"To determine the chunk size of the array representation on disk, call the setchunks function prior to saving:","category":"page"},{"location":"examples/Saving and rechunking/","page":"Saving and rechunking","title":"Saving and rechunking","text":"julia> using YAXArrays, Zarr, NetCDF\n\njulia> a = YAXArray(rand(10,20));\n\njulia> f = tempname();\n\njulia> a_chunked = setchunks(a,(5,10));\n\njulia> savecube(a_chunked,f,backend=:zarr);\n\njulia> Cube(f).chunks\n2Ã—2 DiskArrays.GridChunks{2}:\n (1:5, 1:10)   (1:5, 11:20)\n (6:10, 1:10)  (6:10, 11:20)","category":"page"},{"location":"examples/Saving and rechunking/","page":"Saving and rechunking","title":"Saving and rechunking","text":"Alternatively chunk sizes can be given by dimension name, so the following results in the same chunks:","category":"page"},{"location":"examples/Saving and rechunking/","page":"Saving and rechunking","title":"Saving and rechunking","text":"a_chunked = setchunks(a,(Dim_2=10, Dim_1=5));","category":"page"},{"location":"examples/Saving and rechunking/#Rechunking-Datasets","page":"Saving and rechunking","title":"Rechunking Datasets","text":"","category":"section"},{"location":"examples/Saving and rechunking/#Set-Chunks-by-Axis","page":"Saving and rechunking","title":"Set Chunks by Axis","text":"","category":"section"},{"location":"examples/Saving and rechunking/","page":"Saving and rechunking","title":"Saving and rechunking","text":"Set chunk size for each axis occuring in a dataset. This will be applied to all variables in the dataset:","category":"page"},{"location":"examples/Saving and rechunking/","page":"Saving and rechunking","title":"Saving and rechunking","text":"using YAXArrays, Zarr\nds = Dataset(x = YAXArray(rand(10,20)), y = YAXArray(rand(10)), z = YAXArray(rand(10,20,5)));\ndschunked = setchunks(ds,Dict(\"Dim_1\"=>5, \"Dim_2\"=>10, \"Dim_3\"=>2));\nf = tempname();\nsavedataset(dschunked,path=f,driver=:zarr)","category":"page"},{"location":"examples/Saving and rechunking/#Set-chunking-by-Variable","page":"Saving and rechunking","title":"Set chunking by Variable","text":"","category":"section"},{"location":"examples/Saving and rechunking/","page":"Saving and rechunking","title":"Saving and rechunking","text":"The following will set the chunk size for each Variable separately and results in exactly the same chunking as the example above","category":"page"},{"location":"examples/Saving and rechunking/","page":"Saving and rechunking","title":"Saving and rechunking","text":"using YAXArrays, Zarr\nds = Dataset(x = YAXArray(rand(10,20)), y = YAXArray(rand(10)), z = YAXArray(rand(10,20,5)));\ndschunked = setchunks(ds,(x = (5,10), y = Dict(\"Dim_1\"=>5), z = (Dim_1 = 5, Dim_2 = 10, Dim_3 = 2)));\nf = tempname();\nsavedataset(dschunked,path=f,driver=:zarr)","category":"page"},{"location":"examples/Saving and rechunking/#Set-chunking-for-all-variables","page":"Saving and rechunking","title":"Set chunking for all variables","text":"","category":"section"},{"location":"examples/Saving and rechunking/","page":"Saving and rechunking","title":"Saving and rechunking","text":"The following code snippet only works when all member variables of the dataset have the same shape and sets the output chunks for all arrays. ","category":"page"},{"location":"examples/Saving and rechunking/","page":"Saving and rechunking","title":"Saving and rechunking","text":"using YAXArrays, Zarr\nds = Dataset(x = YAXArray(rand(10,20)), y = YAXArray(rand(10,20)), z = YAXArray(rand(10,20)));\ndschunked = setchunks(ds,(5,10));\nf = tempname();\nsavedataset(dschunked,path=f,driver=:zarr)","category":"page"},{"location":"examples/Time Mean/#How-to-calculate-a-time-mean","page":"Time Mean","title":"How to calculate a time mean","text":"","category":"section"},{"location":"examples/Time Mean/","page":"Time Mean","title":"Time Mean","text":"using ESDL\nc = Cube()\ncitaly = c[var = [\"air_temperature_2m\", \"evaporation\"], region=\"Italy\", time=2001:2003]\nmapslices(mean âˆ˜ skipmissing, c, dims=\"Time\")","category":"page"},{"location":"examples/Time Mean/#Distributed-calculations","page":"Time Mean","title":"Distributed calculations","text":"","category":"section"},{"location":"examples/Time Mean/#Local-machine","page":"Time Mean","title":"Local machine","text":"","category":"section"},{"location":"examples/Time Mean/","page":"Time Mean","title":"Time Mean","text":"It is possible to distribute the calculations over multiple process. The following code does a time mean over all grid points using multiple CPU over a local machine.","category":"page"},{"location":"examples/Time Mean/","page":"Time Mean","title":"Time Mean","text":"using Distributed\naddprocs(2)\n\n@everywhere using Pkg\n@everywhere Pkg.activate(\".\")\n@everywhere using ESDL\n@everywhere using Statistics\n\n@everywhere function mymean(output, pixel)\n       output = mean(pixel)\nend\n\nc = Cube()\ntair = subsetcube(c,variable=\"air_temperature_2m\", time=2001:2016)\ntair_c = map(t->t-273.15, tair)\n\nindims = InDims(TimeAxis)\noutdims = OutDims()\n\nresultcube = mapCube(mymean, tair_c, indims=indims, outdims=outdims)","category":"page"},{"location":"examples/Time Mean/","page":"Time Mean","title":"Time Mean","text":"In the last example, mapCube was used to map the mymean function. mapslices is a convenient function that can replace mapCube, where you can omit defining an extra function with the output argument as an input (e.g. mymean). It is possible to simply use mapslice","category":"page"},{"location":"examples/Time Mean/","page":"Time Mean","title":"Time Mean","text":"resultcube = mapslices(mean âˆ˜ skipmissing, c, dims=\"time\")","category":"page"},{"location":"examples/Time Mean/#SLURM-cluster","page":"Time Mean","title":"SLURM cluster","text":"","category":"section"},{"location":"examples/Time Mean/","page":"Time Mean","title":"Time Mean","text":"It is also possible to distribute easily the workload on a cluster, with little modification to the code. The following code does a time mean over all grid points using multiple CPU over a SLURM cluster. To do so, we use the ClusterManagers package.","category":"page"},{"location":"examples/Time Mean/","page":"Time Mean","title":"Time Mean","text":"using Distributed\nusing ClusterManagers\n\naddprocs(SlurmManager(10))\n\n@everywhere using Pkg\n@everywhere Pkg.activate(\".\")\n@everywhere using ESDL\n@everywhere using Statistics\n\ninpath=\"zg1000_AERday_CanESM5_esm-hist_r6i1p1f1_gn_18500101-20141231.nc\"\n\nc = Cube(inpath, \"zg1000\")\n\nresultcube = mapslices(mean âˆ˜ skipmissing, c, dims=\"time\")","category":"page"},{"location":"tutorials/tutorial/#YAXArray-tutorial","page":"Tutorial","title":"YAXArray tutorial","text":"","category":"section"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"If you are interested in learning how to work with YAXArrays for different use cases you can follow along one of the following tutorials. ","category":"page"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"Currently the overview tutorial is located at ESDLTutorials Repository\nYou can find further tutorial videos at the EO College. Beware that the syntax in the video tutorials might be slightly changed. \nthe other tutorials are still work in progress.","category":"page"},{"location":"tutorials/tutorial/#General-overview-of-the-functionality-of-YAXArrays","page":"Tutorial","title":"General overview of the functionality of YAXArrays","text":"","category":"section"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"This tutorial provides a broad overview about the features of YAXArrays.","category":"page"},{"location":"tutorials/tutorial/#Table-style-iteration-over-YAXArrays","page":"Tutorial","title":"Table-style iteration over YAXArrays","text":"","category":"section"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"Work in progress","category":"page"},{"location":"tutorials/tutorial/","page":"Tutorial","title":"Tutorial","text":"Sometimes you want to combine the data that is represented in the data cube with other datasets, which are best described as a data frame.  In this tutorial you will learn how to use the Tables.jl interface to iterate over the data in the YAXArray.","category":"page"},{"location":"tutorials/tutorial/#Combining-multiple-tiff-files-into-a-zarr-based-datacube","page":"Tutorial","title":"Combining multiple tiff files into a zarr based datacube","text":"","category":"section"},{"location":"howtos/howtos/#How-Tos","page":"How Tos","title":"How Tos","text":"","category":"section"},{"location":"howtos/howtos/","page":"How Tos","title":"How Tos","text":"If you have a specific use case that you would like to solve with YAXArrays hopefully, you are going to find a solution here. If you can't find a how to for your use case, feel free to open an issue with a description of it. ","category":"page"},{"location":"howtos/howtos/#Use-YAXArrays-on-a-managed-Cluster-with-SlurmClusterManagers","page":"How Tos","title":"Use YAXArrays on a managed Cluster with SlurmClusterManagers","text":"","category":"section"},{"location":"howtos/howtos/#Performance-Tips","page":"How Tos","title":"Performance Tips","text":"","category":"section"},{"location":"api/#Public-API","page":"Docstring Reference","title":"Public API","text":"","category":"section"},{"location":"api/","page":"Docstring Reference","title":"Docstring Reference","text":"DocTestSetup= quote\nusing YAXArrays\nend","category":"page"},{"location":"api/","page":"Docstring Reference","title":"Docstring Reference","text":"Modules = [YAXArrays, YAXArrays.Cubes, YAXArrays.Cubes.Axes, YAXArrays.DAT, YAXArrays.Datasets,YAXArrays.YAXTools]\nPrivate = false","category":"page"},{"location":"api/#YAXArrays.Cubes","page":"Docstring Reference","title":"YAXArrays.Cubes","text":"The functions provided by YAXArrays are supposed to work on different types of cubes. This module defines the interface for all Data types that\n\n\n\n\n\n","category":"module"},{"location":"api/#YAXArrays.Cubes.YAXArray","page":"Docstring Reference","title":"YAXArrays.Cubes.YAXArray","text":"YAXArray{T,N}\n\nAn array labelled with named axes that have values associated with them. It can wrap normal arrays or, more typically DiskArrays.\n\nFields\n\naxes a Vector{CubeAxis} containing the Axes of the Cube\ndata N-D array containing the data\n\n\n\n\n\n","category":"type"},{"location":"api/#YAXArrays.Cubes.caxes","page":"Docstring Reference","title":"YAXArrays.Cubes.caxes","text":"Returns the axes of a Cube\n\n\n\n\n\n","category":"function"},{"location":"api/#YAXArrays.Cubes.concatenatecubes-Tuple{Any, CubeAxis}","page":"Docstring Reference","title":"YAXArrays.Cubes.concatenatecubes","text":"function concatenateCubes(cubelist, cataxis::CategoricalAxis)\n\nConcatenates a vector of datacubes that have identical axes to a new single cube along the new axis cataxis\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.Cubes.readcubedata-Tuple{Any}","page":"Docstring Reference","title":"YAXArrays.Cubes.readcubedata","text":"readcubedata(cube)\n\nGiven any array implementing the YAXArray interface it returns an in-memory YAXArray from it.\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.Cubes.setchunks-Tuple{YAXArray, Any}","page":"Docstring Reference","title":"YAXArrays.Cubes.setchunks","text":"setchunks(c::YAXArray,chunks)\n\nResets the chunks of a YAXArray and returns a new YAXArray. Note that this will not change the chunking of the underlying data itself,  it will just make the data \"look\" like it had a different chunking. If you need a persistent on-disk representation of this chunking, use savecube on the resulting array. The chunks argument can take one of the following forms:\n\na DiskArrays.GridChunks object\na tuple specifying the chunk size along each dimension\nan AbstractDict or NamedTuple mapping one or more axis names to chunk sizes\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.Cubes.subsetcube","page":"Docstring Reference","title":"YAXArrays.Cubes.subsetcube","text":"This function calculates a subset of a cube's data\n\n\n\n\n\n","category":"function"},{"location":"api/#YAXArrays.Cubes.Axes","page":"Docstring Reference","title":"YAXArrays.Cubes.Axes","text":"The Axes module handles the Axes of a data cube.  It provides the following exports:\n\nCategoricalAxis\nCubeAxis\nRangeAxis\ngetAxis\n\n\n\n\n\n","category":"module"},{"location":"api/#YAXArrays.Cubes.Axes.CategoricalAxis","page":"Docstring Reference","title":"YAXArrays.Cubes.Axes.CategoricalAxis","text":"struct CategoricalAxis{T,S,RT}\n\nTo represent axes that are categorical, where T is the element type. The type parameter S denotes the axis name (a symbol). The default constructor is:\n\nCategoricalAxis(axname::String,values::Vector{T})\n\n\n\n\n\n","category":"type"},{"location":"api/#YAXArrays.Cubes.Axes.CubeAxis","page":"Docstring Reference","title":"YAXArrays.Cubes.Axes.CubeAxis","text":"abstract type CubeAxis{T,S}\n\nSupertype of all axes. Every CubeAxis is an 1D Cube itself and can be passed to mapCube operations. In detail CubeAxis is an AbstractArray{Int, 1}\n\n\n\n\n\n","category":"type"},{"location":"api/#YAXArrays.Cubes.Axes.RangeAxis","page":"Docstring Reference","title":"YAXArrays.Cubes.Axes.RangeAxis","text":"RangeAxis{T,S,R}\n\nTo represent axes that are numerical, where T is the element type. The type parameter S denotes the axis name (a symbol) and R the type of the range which is used to represent the axis values. The default constructor is:\n\nRangeAxis(axname::String,values::Range{T})\n\n\n\n\n\n","category":"type"},{"location":"api/#YAXArrays.Cubes.Axes.getAxis-Tuple{Any, Any}","page":"Docstring Reference","title":"YAXArrays.Cubes.Axes.getAxis","text":"getAxis(desc, c)\n\nGiven an Axis description and a cube, returns the corresponding axis of the cube. The Axis description can be:\n\nthe name as a string or symbol.\nan Axis object\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.DAT.InDims","page":"Docstring Reference","title":"YAXArrays.DAT.InDims","text":"InDims(axisdesc...;...)\n\nCreates a description of an Input Data Cube for cube operations. Takes a single   or multiple axis descriptions as first arguments. Alternatively a MovingWindow(@ref) struct can be passed to include   neighbour slices of one or more axes in the computation.    Axes can be specified by their   name (String), through an Axis type, or by passing a concrete axis.\n\nKeyword arguments\n\nartype how shall the array be represented in the inner function. Defaults to Array, alternatives are DataFrame or AsAxisArray\nfilter define some filter to skip the computation, e.g. when all values are missing. Defaults to   AllMissing(), possible values are AnyMissing(), AnyOcean(), StdZero(), NValid(n)   (for at least n non-missing elements). It is also possible to provide a custom one-argument function   that takes the array and returns true if the compuation shall be skipped and false otherwise.\nwindow_oob_value if one of the input dimensions is a MowingWindow, this value will be used to fill out-of-bounds areas\n\n\n\n\n\n","category":"type"},{"location":"api/#YAXArrays.DAT.MovingWindow","page":"Docstring Reference","title":"YAXArrays.DAT.MovingWindow","text":"MovingWindow(desc, pre, after)\n\nConstructs a MovingWindow object to be passed to an InDims constructor to define that the axis in desc shall participate in the inner function (i.e. shall be looped over), but inside the inner function pre values before and after values after the center value will be passed as well. \n\nFor example passing MovingWindow(\"Time\", 2, 0) will loop over the time axis and  always pass the current time step plus the 2 previous steps. So in the inner function the array will have an additional dimension of size 3.    \n\n\n\n\n\n","category":"type"},{"location":"api/#YAXArrays.DAT.OutDims-Tuple","page":"Docstring Reference","title":"YAXArrays.DAT.OutDims","text":"OutDims(axisdesc;...)\n\nCreates a description of an Output Data Cube for cube operations. Takes a single   or a Vector/Tuple of axes as first argument. Axes can be specified by their   name (String), through an Axis type, or by passing a concrete axis.\n\naxisdesc: List of input axis names\nbackend : specifies the dataset backend to write data to, must be either :auto or a key in YAXArrayBase.backendlist\nupdate : specifies wether the function operates inplace or if an output is returned\nartype : specifies the Array type inside the inner function that is mapped over\nchunksize: A Dict specifying the chunksizes for the output dimensions of the cube, or :input to copy chunksizes from input cube axes or :max to not chunk the inner dimensions\nouttype: force the output type to a specific type, defaults to Any which means that the element type of the first input cube is used\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.DAT.CubeTable-Tuple{}","page":"Docstring Reference","title":"YAXArrays.DAT.CubeTable","text":"CubeTable()\n\nFunction to turn a DataCube object into an iterable table. Takes a list of as arguments, specified as a name=cube expression. For example CubeTable(data=cube1,country=cube2) would generate a Table with the entries data and country, where data contains the values of cube1 and country the values of cube2. The cubes are matched and broadcasted along their axes like in mapCube.\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.DAT.cubefittable-Tuple{Any, Any, Any}","page":"Docstring Reference","title":"YAXArrays.DAT.cubefittable","text":"cubefittable(tab,o,fitsym;post=getpostfunction(o),kwargs...)\n\nExecutes fittable on the CubeTable tab with the (Weighted-)OnlineStat o, looping through the values specified by fitsym. Finally, writes the results from the TableAggregator to an output data cube.\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.DAT.fittable-Tuple{YAXArrays.DAT.CubeIterator, Any, Any}","page":"Docstring Reference","title":"YAXArrays.DAT.fittable","text":"fittable(tab,o,fitsym;by=(),weight=nothing)\n\nLoops through an iterable table tab and thereby fitting an OnlineStat o with the values specified through fitsym. Optionally one can specify a field (or tuple) to group by. Any groupby specifier can either be a symbol denoting the entry to group by or an anynymous function calculating the group from a table row.\n\nFor example the following would caluclate a weighted mean over a cube weighted by grid cell area and grouped by country and month:\n\nfittable(iter,WeightedMean,:tair,weight=(i->abs(cosd(i.lat))),by=(i->month(i.time),:country))\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.DAT.mapCube-Tuple{Function, Tuple, Vararg{Any}}","page":"Docstring Reference","title":"YAXArrays.DAT.mapCube","text":"mapCube(fun, cube, addargs...;kwargs...)\n\nMap a given function fun over slices of the data cube cube.      The additional arguments addargs will be forwarded to the inner function fun.\n\nKeyword arguments\n\nmax_cache=YAXDefaults.max_cache maximum size of blocks that are read into memory, defaults to approx 10Mb\nindims::InDims List of input cube descriptors of type InDims for each input data cube\noutdims::OutDims List of output cube descriptors of type OutDims for each output cube\ninplace does the function write to an output array inplace or return a single value> defaults to true\nispar boolean to determine if parallelisation should be applied, defaults to true if workers are available.\nshowprog boolean indicating if a ProgressMeter shall be shown\ninclude_loopvars boolean to indicate if the varoables looped over should be added as function arguments\nnthreads number of threads for the computation, defaults to Threads.nthreads for every worker.\nloopchunksize determines the chunk sizes of variables which are looped over, a dict\nkwargs additional keyword arguments are passed to the inner function\n\nThe first argument is always the function to be applied, the second is the input cube or a tuple of input cubes if needed.\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.Datasets.Dataset-Tuple{}","page":"Docstring Reference","title":"YAXArrays.Datasets.Dataset","text":"Dataset(; properties = Dict{String,Any}, cubes...)\n\nConstruct a YAXArray Dataset with global attributes properties a and a list of named YAXArrays cubes...\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.Datasets.Cube-Tuple{Dataset}","page":"Docstring Reference","title":"YAXArrays.Datasets.Cube","text":"Cube(ds::Dataset; joinname=\"Variable\")\n\nConstruct a single YAXArray from the dataset ds  by concatenating the cubes in the datset on the joinname dimension.\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.Datasets.savecube-Tuple{Any, AbstractString}","page":"Docstring Reference","title":"YAXArrays.Datasets.savecube","text":"savecube(cube,name::String)\n\nSave a YAXArray to the path. \n\nExtended Help\n\nThe keyword arguments are:\n\nname:\ndatasetaxis=\"Variable\" special treatment of a categorical axis that gets written into separate zarr arrays\nmax_cache: The number of bits that are used as cache for the data handling.\nbackend: The backend, that is used to save the data. Fallsback to searching the backend according to the extension of the path.\ndriver \noverwrite::Bool=false overwrite cube if it already exists\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.Datasets.to_dataset-Tuple{Any}","page":"Docstring Reference","title":"YAXArrays.Datasets.to_dataset","text":"to_dataset(c;datasetaxis = \"Variable\", name = \"layer\")  \n\nConvert a Data Cube into a Dataset. It is possible to treat one of  the Cube's axes as a \"DatasetAxis\" i.e. the cube will be split into  different parts that become variables in the Dataset. If no such  axis is specified or found, there will only be a single variable  in the dataset with the name name\n\n\n\n\n\n","category":"method"},{"location":"api/#Internal-API","page":"Docstring Reference","title":"Internal API","text":"","category":"section"},{"location":"api/","page":"Docstring Reference","title":"Docstring Reference","text":"Modules = [YAXArrays, YAXArrays.Cubes, YAXArrays.Cubes.Axes, YAXArrays.DAT,YAXArrays.Datasets,YAXArrays.YAXTools]\nPublic = false","category":"page"},{"location":"api/#YAXArrays.YAXDefaults","page":"Docstring Reference","title":"YAXArrays.YAXDefaults","text":"Default configuration for YAXArrays, has the following fields:\n\nworkdir[]::String = \"./\" The default location for temporary cubes.\nrecal[]::Bool = false set to true if you want @loadOrGenerate to always recalculate the results.\nchunksize[]::Any = :input Set the default output chunksize.\nmax_cache[]::Float64 = 1e8 The maximum cache used by mapCube.\ncubedir[]::\"\" the default location for Cube() without an argument.\nsubsetextensions::Array{Any} = [] List of registered functions, that convert subsetting input into dimension boundaries. \n\n\n\n\n\n","category":"constant"},{"location":"api/#YAXArrays.Cubes.CleanMe","page":"Docstring Reference","title":"YAXArrays.Cubes.CleanMe","text":"mutable struct CleanMe\n\nStruct which describes data paths and their persistency. Non-persistend paths/files are removed at finalize step\n\n\n\n\n\n","category":"type"},{"location":"api/#YAXArrays.Cubes.clean-Tuple{YAXArrays.Cubes.CleanMe}","page":"Docstring Reference","title":"YAXArrays.Cubes.clean","text":"clean(c::CleanMe)\n\nfinalizer function for CleanMe struct. The main process removes all directories/files which are not persistent.\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.Cubes.copydata-Tuple{Any, Any, Any}","page":"Docstring Reference","title":"YAXArrays.Cubes.copydata","text":"copydata(outar, inar, copybuf)\n\nInternal function which copies the data from the input inar into the output outar at the copybuf positions.\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.Cubes.getcleaner-Tuple{Any}","page":"Docstring Reference","title":"YAXArrays.Cubes.getcleaner","text":"Internal\n\ngetcleaner(x)\n\nGet the cleaner for a YAXArray. This function is used to separate the cleaner access from the implementation in the Array.\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.Cubes.optifunc-NTuple{7, Any}","page":"Docstring Reference","title":"YAXArrays.Cubes.optifunc","text":"optifunc(s, maxbuf, incs, outcs, insize, outsize, writefac)\n\nInternal\n\nThis function is going to be minimized to detect the best possible chunk setting for the rechunking of the data.\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.Cubes.Axes.abshalf-Tuple{Any}","page":"Docstring Reference","title":"YAXArrays.Cubes.Axes.abshalf","text":"abshalf\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.Cubes.Axes.axVal2Index-Tuple{RangeAxis{<:Any, <:Any, <:AbstractRange}, Any}","page":"Docstring Reference","title":"YAXArrays.Cubes.Axes.axVal2Index","text":"axVal2Index\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.Cubes.Axes.axVal2Index_lb-Tuple{RangeAxis, Any}","page":"Docstring Reference","title":"YAXArrays.Cubes.Axes.axVal2Index_lb","text":"axVal2Index_lb\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.Cubes.Axes.axVal2Index_ub-Tuple{RangeAxis, Any}","page":"Docstring Reference","title":"YAXArrays.Cubes.Axes.axVal2Index_ub","text":"axVal2Index_ub\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.Cubes.Axes.axcopy-Tuple{RangeAxis, Any}","page":"Docstring Reference","title":"YAXArrays.Cubes.Axes.axcopy","text":"axcopy(x,vals)\n\nMakes a full copy of a CubeAxis with the values vals\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.Cubes.Axes.axisfrombb-Tuple{Any, Any, Any}","page":"Docstring Reference","title":"YAXArrays.Cubes.Axes.axisfrombb","text":"axisfrombb\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.Cubes.Axes.axname-Union{Tuple{Type{<:CubeAxis{<:Any, U}}}, Tuple{U}} where U","page":"Docstring Reference","title":"YAXArrays.Cubes.Axes.axname","text":"axname\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.Cubes.Axes.axsym-Union{Tuple{CubeAxis{<:Any, S}}, Tuple{S}} where S","page":"Docstring Reference","title":"YAXArrays.Cubes.Axes.axsym","text":"axsym\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.Cubes.Axes.convert_time-Tuple{Type{<:Dates.TimeType}, Dates.TimeType}","page":"Docstring Reference","title":"YAXArrays.Cubes.Axes.convert_time","text":"convert_time\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.Cubes.Axes.findAxis-Tuple{Any, Any}","page":"Docstring Reference","title":"YAXArrays.Cubes.Axes.findAxis","text":"findAxis(desc, c)\n\nGiven an Axis description and a cube return the index of the Axis. The Axis description can be:\n\nthe name as a string or symbol.\nan Axis object\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.Cubes.Axes.getOutAxis-NTuple{5, Any}","page":"Docstring Reference","title":"YAXArrays.Cubes.Axes.getOutAxis","text":"getOutAxis\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.Cubes.Axes.get_bb-Tuple{RangeAxis}","page":"Docstring Reference","title":"YAXArrays.Cubes.Axes.get_bb","text":"get_bb\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.Cubes.Axes.get_descriptor-Tuple{String}","page":"Docstring Reference","title":"YAXArrays.Cubes.Axes.get_descriptor","text":"get_descriptor(a)\n\nGet the descriptor of an Axis.  This is used to dispatch on the descriptor. \n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.Cubes.Axes.get_step-Tuple{AbstractRange}","page":"Docstring Reference","title":"YAXArrays.Cubes.Axes.get_step","text":"get_step\n\nreturns stepwidth of the RangeAxis\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.Cubes.Axes.match_axis-Tuple{YAXArrays.Cubes.Axes.ByName, Any}","page":"Docstring Reference","title":"YAXArrays.Cubes.Axes.match_axis","text":"match_axis\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.Cubes.Axes.renameaxis-Union{Tuple{V}, Tuple{T}, Tuple{RangeAxis{T, <:Any, V}, Any}} where {T, V}","page":"Docstring Reference","title":"YAXArrays.Cubes.Axes.renameaxis","text":"renameaxis\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.Cubes.caxes-Tuple{CubeAxis}","page":"Docstring Reference","title":"YAXArrays.Cubes.caxes","text":"caxes\n\nEmbeds  Cube inside a new Cube\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.DAT.DATConfig","page":"Docstring Reference","title":"YAXArrays.DAT.DATConfig","text":"Configuration object of a DAT process. This holds all necessary information to perform the calculations. It contains the following fields:\n\nincubes::NTuple{NIN,InputCube} The input data cubes\noutcube::NTuple{NOUT,OutputCube} The output data cubes\n\nallInAxes     :: Vector LoopAxes      :: Vector ispar         :: Bool loopcachesize :: Vector{Int} maxcache fu inplace      :: Bool includeloopvars:: Bool ntr addargs kwargs\n\n\n\n\n\n","category":"type"},{"location":"api/#YAXArrays.DAT.InputCube","page":"Docstring Reference","title":"YAXArrays.DAT.InputCube","text":"Internal representation of an input cube for DAT operations\n\ncube\nThe input data\ndesc\nThe input description given by the user/registration\naxesSmall\nList of axes that were actually selected through the description\nicolon\ncolonperm\nloopinds\nIndices of loop axes that this cube does not contain, i.e. broadcasts\ncachesize\nwindow\niwindow\nwindowloopinds\niall\n\n\n\n\n\n","category":"type"},{"location":"api/#YAXArrays.DAT.OutputCube","page":"Docstring Reference","title":"YAXArrays.DAT.OutputCube","text":"Internal representation of an output cube for DAT operations\n\nFields\n\ncube\nThe actual outcube cube, once it is generated\ncube_unpermuted\nThe unpermuted output cube\ndesc\nThe description of the output axes as given by users or registration\naxesSmall\nThe list of output axes determined through the description\nallAxes\nList of all the axes of the cube\nloopinds\nIndex of the loop axes that are broadcasted for this output cube\ninnerchunks\nouttype\nElementtype of the outputcube\n\n\n\n\n\n","category":"type"},{"location":"api/#YAXArrays.DAT.YAXColumn","page":"Docstring Reference","title":"YAXArrays.DAT.YAXColumn","text":"YAXColumn\n\nA struct representing a single column of a YAXArray partitioned Table     # Fields \n\ninarBC\ninds\n\n\n\n\n\n\n\n","category":"type"},{"location":"api/#YAXArrays.DAT.cmpcachmisses-Tuple{Any, Any}","page":"Docstring Reference","title":"YAXArrays.DAT.cmpcachmisses","text":"Function that compares two cache miss specifiers by their importance\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.DAT.getFrontPerm-Tuple{Any, Any}","page":"Docstring Reference","title":"YAXArrays.DAT.getFrontPerm","text":"Calculate an axis permutation that brings the wanted dimensions to the front\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.DAT.getLoopCacheSize-NTuple{5, Any}","page":"Docstring Reference","title":"YAXArrays.DAT.getLoopCacheSize","text":"Calculate optimal Cache size to DAT operation\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.Cubes.setchunks-Tuple{Dataset, Any}","page":"Docstring Reference","title":"YAXArrays.Cubes.setchunks","text":"setchunks(c::Dataset,chunks)\n\nResets the chunks of all or a subset YAXArrays in the dataset and returns a new Dataset. Note that this will not change the chunking of the underlying data itself,  it will just make the data \"look\" like it had a different chunking. If you need a persistent on-disk representation of this chunking, use savedataset on the resulting array. The chunks argument can take one of the following forms:\n\na NamedTuple or AbstractDict mapping from variable name to a description of the desired variable chunks\na NamedTuple or AbstractDict mapping from dimension name to a description of the desired variable chunks\na description of the desired variable chunks applied to all members of the Dataset\n\nwhere a description of the desired variable chunks can take one of the following forms:\n\na DiskArrays.GridChunks object\na tuple specifying the chunk size along each dimension\nan AbstractDict or NamedTuple mapping one or more axis names to chunk sizes\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.Datasets.collectfromhandle-Tuple{Any, Any, Any}","page":"Docstring Reference","title":"YAXArrays.Datasets.collectfromhandle","text":"Extracts a YAXArray from a dataset handle that was just created from a arrayinfo\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.Datasets.createdataset-Tuple{Any, Any}","page":"Docstring Reference","title":"YAXArrays.Datasets.createdataset","text":"function createdataset(DS::Type,axlist; kwargs...)\n\nCreates a new dataset with axes specified in axlist. Each axis must be a subtype   of CubeAxis. A new empty Zarr array will be created and can serve as a sink for   mapCube operations.\n\nKeyword arguments\n\npath=\"\" location where the new cube is stored\nT=Union{Float32,Missing} data type of the target cube\nchunksize = ntuple(i->length(axlist[i]),length(axlist)) chunk sizes of the array\nchunkoffset = ntuple(i->0,length(axlist)) offsets of the chunks\npersist::Bool=true shall the disk data be garbage-collected when the cube goes out of scope?\noverwrite::Bool=false overwrite cube if it already exists\nproperties=Dict{String,Any}() additional cube properties\nfillvalue= T>:Missing ? defaultfillval(Base.nonmissingtype(T)) : nothing fill value\ndatasetaxis=\"Variable\" special treatment of a categorical axis that gets written into separate zarr arrays\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.Datasets.getarrayinfo-Tuple{Any, Any}","page":"Docstring Reference","title":"YAXArrays.Datasets.getarrayinfo","text":"Extract necessary information to create a YAXArrayBase dataset from a name and YAXArray pair \n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.Datasets.testrange-Tuple{Any}","page":"Docstring Reference","title":"YAXArrays.Datasets.testrange","text":"Test if data in x can be approximated by a step range\n\n\n\n\n\n","category":"method"},{"location":"howtos/dataaccess/#Loading-a-single-file-as-a-data-cube","page":"-","title":"Loading a single file as a data cube","text":"","category":"section"},{"location":"howtos/dataaccess/","page":"-","title":"-","text":"In this example we are going to use a NetCDF file but this should be very similar for other data backends. To open a single data file we first need to load the appropriate backend package via using NetCDF. ","category":"page"},{"location":"tutorials/iterators/#Table-style-iteration-over-YAXArrays","page":"-","title":"Table-style iteration over YAXArrays","text":"","category":"section"},{"location":"tutorials/iterators/","page":"-","title":"-","text":"Sometimes you want to combine the data that is represented in the data cube with other datasets, which are best described as a data frame.  In this tutorial you will learn how to use the Tables.jl interface to iterate over the data in the YAXArray.","category":"page"},{"location":"howtos/applyingfunctions/#How-to-apply-functions-on-YAXArrays","page":"How to apply functions on YAXArrays","title":"How to apply functions on YAXArrays","text":"","category":"section"},{"location":"howtos/applyingfunctions/","page":"How to apply functions on YAXArrays","title":"How to apply functions on YAXArrays","text":"To apply user defined functions on a YAXArray data type we can use the map function, mapslices function or the mapCube function.  Which of these functions should be used depends on the layout of the data,  that the user defined function should be applied on. ","category":"page"},{"location":"howtos/applyingfunctions/#Apply-a-function-on-every-element-of-a-datacube","page":"How to apply functions on YAXArrays","title":"Apply a function on every element of a datacube","text":"","category":"section"},{"location":"howtos/applyingfunctions/","page":"How to apply functions on YAXArrays","title":"How to apply functions on YAXArrays","text":"The map function can be used to apply a function on every entry of a YAXArray without taking the dimensions into account. This will lazily register the mapped function which is applied when the YAXArray is either accessed or when more involved computations are made. ","category":"page"},{"location":"howtos/applyingfunctions/","page":"How to apply functions on YAXArrays","title":"How to apply functions on YAXArrays","text":"If we set up a dummy data cube which has all numbers between 1 and 10000.","category":"page"},{"location":"howtos/applyingfunctions/","page":"How to apply functions on YAXArrays","title":"How to apply functions on YAXArrays","text":"    using YAXArrays\n    axes = [RangeAxis(\"Lon\", 1:10), RangeAxis(\"Lat\", 1:10), RangeAxis(\"Time\", 1:100)]\n    original = YAXArray(axes, reshape(1:10000, (10,10,100)))","category":"page"},{"location":"howtos/applyingfunctions/","page":"How to apply functions on YAXArrays","title":"How to apply functions on YAXArrays","text":"with one at the first position:","category":"page"},{"location":"howtos/applyingfunctions/","page":"How to apply functions on YAXArrays","title":"How to apply functions on YAXArrays","text":"original[1,:,1]","category":"page"},{"location":"howtos/applyingfunctions/","page":"How to apply functions on YAXArrays","title":"How to apply functions on YAXArrays","text":"now we can substract 1 from all elements of this cube","category":"page"},{"location":"howtos/applyingfunctions/","page":"How to apply functions on YAXArrays","title":"How to apply functions on YAXArrays","text":"    substracted = map(x-> x-1, original)","category":"page"},{"location":"howtos/applyingfunctions/","page":"How to apply functions on YAXArrays","title":"How to apply functions on YAXArrays","text":"substracted is a cube of the same size as original, and the applied function is registered, so that it is applied as soon as the elements of substracted are either accessed or further used in other computations. ","category":"page"},{"location":"howtos/applyingfunctions/","page":"How to apply functions on YAXArrays","title":"How to apply functions on YAXArrays","text":"    substracted[1,:,1]","category":"page"},{"location":"howtos/applyingfunctions/#Apply-a-function-along-dimensions-of-a-single-cube","page":"How to apply functions on YAXArrays","title":"Apply a function along dimensions of a single cube","text":"","category":"section"},{"location":"howtos/applyingfunctions/","page":"How to apply functions on YAXArrays","title":"How to apply functions on YAXArrays","text":"If an function should work along a certain dimension of the data you can use the 'mapslices' function to easily apply this function. This doesn't give you the flexibility of the mapCube function but it is easier to use for simple functions. ","category":"page"},{"location":"howtos/applyingfunctions/","page":"How to apply functions on YAXArrays","title":"How to apply functions on YAXArrays","text":"If we set up a dummy data cube which has all numbers between 1 and 10000.","category":"page"},{"location":"howtos/applyingfunctions/","page":"How to apply functions on YAXArrays","title":"How to apply functions on YAXArrays","text":"    using YAXArrays\n    axes = [RangeAxis(\"Lon\", 1:10), RangeAxis(\"Lat\", 1:10), RangeAxis(\"Time\", 1:100)]\n    original = YAXArray(axes, reshape(1:10000, (10,10,100)))","category":"page"},{"location":"howtos/applyingfunctions/","page":"How to apply functions on YAXArrays","title":"How to apply functions on YAXArrays","text":"and then we would like to compute the sum over the Time dimension:","category":"page"},{"location":"howtos/applyingfunctions/","page":"How to apply functions on YAXArrays","title":"How to apply functions on YAXArrays","text":"    timesum = mapslices(sum, original, dims=\"Time\")","category":"page"},{"location":"howtos/applyingfunctions/","page":"How to apply functions on YAXArrays","title":"How to apply functions on YAXArrays","text":"this reduces over the time dimension and gives us the following values","category":"page"},{"location":"howtos/applyingfunctions/","page":"How to apply functions on YAXArrays","title":"How to apply functions on YAXArrays","text":"    timesum[:,:]","category":"page"},{"location":"howtos/applyingfunctions/","page":"How to apply functions on YAXArrays","title":"How to apply functions on YAXArrays","text":"You can also apply a function along multiple dimensions of the same data cube. ","category":"page"},{"location":"howtos/applyingfunctions/","page":"How to apply functions on YAXArrays","title":"How to apply functions on YAXArrays","text":"    lonlatsum = mapslices(sum, original, dims=(\"Lon\", \"Lat\"))","category":"page"},{"location":"howtos/applyingfunctions/#How-to-combine-multiple-cubes-in-one-computation","page":"How to apply functions on YAXArrays","title":"How to combine multiple cubes in one computation","text":"","category":"section"},{"location":"#YAXArrays.jl","page":"Home","title":"YAXArrays.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Yet another xarray-like Julia package","category":"page"},{"location":"","page":"Home","title":"Home","text":"A package for operating on out-of-core labeled arrays, based on stores like NetCDF, Zarr or GDAL.  ","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"open datasets from a variety of sources (NetCDF, Zarr, ArchGDAL)\ninteroperability with other named axis packages through YAXArrayBase\nefficient mapslices(x) operations on huge multiple arrays, optimized for high-latency data access (object storage, compressed datasets) ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The YAXArray tutorial provides a tutorial explaining how to get started using YAXArrays.","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"tutorials/tutorial.md\",\n    \"howtos/howtos.md\",\n    \"exp/exp.md\"\n]\nDepth = 2","category":"page"},{"location":"#Library-Outline","page":"Home","title":"Library Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"lib/public.md\", \"lib/internals.md\"]","category":"page"},{"location":"#main-index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"lib/public.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"â€“>","category":"page"}]
}
