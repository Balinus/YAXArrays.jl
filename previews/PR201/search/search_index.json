{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"YAXArrays.jl \u00a4 Yet another xarray-like Julia package A package for operating on out-of-core labeled arrays, based on stores like NetCDF, Zarr or GDAL. Info Open datasets from a variety of sources (NetCDF, Zarr, ArchGDAL) Interoperability with other named axis packages through YAXArrayBase Efficient mapslices(x) operations on huge multiple arrays, optimized for high-latency data access (object storage, compressed datasets) Installation \u00a4 In the Julia REPL type: using Pkg Pkg . add ( \"YAXArrays\" ) or ] add YAXArrays The ] character starts the Julia package manager . Hit backspace key to return to Julia prompt. You may check the installed version with: ] st YAXArrays Start using the package: using YAXArrays The YAXArray tutorial provides a tutorial explaining how to get started using YAXArrays. Quick start \u00a4 using YAXArrays yax = YAXArray ( rand ( 10 , 20 , 30 ))","title":"Home"},{"location":"#yaxarraysjl","text":"Yet another xarray-like Julia package A package for operating on out-of-core labeled arrays, based on stores like NetCDF, Zarr or GDAL. Info Open datasets from a variety of sources (NetCDF, Zarr, ArchGDAL) Interoperability with other named axis packages through YAXArrayBase Efficient mapslices(x) operations on huge multiple arrays, optimized for high-latency data access (object storage, compressed datasets)","title":"YAXArrays.jl"},{"location":"#installation","text":"In the Julia REPL type: using Pkg Pkg . add ( \"YAXArrays\" ) or ] add YAXArrays The ] character starts the Julia package manager . Hit backspace key to return to Julia prompt. You may check the installed version with: ] st YAXArrays Start using the package: using YAXArrays The YAXArray tutorial provides a tutorial explaining how to get started using YAXArrays.","title":"Installation"},{"location":"#quick-start","text":"using YAXArrays yax = YAXArray ( rand ( 10 , 20 , 30 ))","title":"Quick start"},{"location":"api/","text":"Public API \u00a4 # YAXArrays.Cubes \u2014 Module . The functions provided by YAXArrays are supposed to work on different types of cubes. This module defines the interface for all Data types that source # YAXArrays.Cubes.YAXArray \u2014 Type . YAXArray { T , N } An array labelled with named axes that have values associated with them. It can wrap normal arrays or, more typically DiskArrays. Fields axes Vector{CubeAxis} containing the Axes of the Cube data length(axes)-dimensional array which holds the data, this can be a lazy DiskArray properties Metadata properties describing the content of the data chunks Representation of the chunking of the data cleaner Cleaner objects to track which objects to tidy up when the YAXArray goes out of scope source # YAXArrays.Cubes.caxes \u2014 Function . Returns the axes of a Cube source # YAXArrays.Cubes.concatenatecubes \u2014 Method . function concatenateCubes ( cubelist , cataxis :: CategoricalAxis ) Concatenates a vector of datacubes that have identical axes to a new single cube along the new axis cataxis source # YAXArrays.Cubes.readcubedata \u2014 Method . readcubedata ( cube ) Given any array implementing the YAXArray interface it returns an in-memory YAXArray from it. source # YAXArrays.Cubes.setchunks \u2014 Method . setchunks ( c :: YAXArray , chunks ) Resets the chunks of a YAXArray and returns a new YAXArray. Note that this will not change the chunking of the underlying data itself, it will just make the data \"look\" like it had a different chunking. If you need a persistent on-disk representation of this chunking, use savecube on the resulting array. The chunks argument can take one of the following forms: a DiskArrays.GridChunks object a tuple specifying the chunk size along each dimension an AbstractDict or NamedTuple mapping one or more axis names to chunk sizes source # YAXArrays.Cubes.subsetcube \u2014 Function . This function calculates a subset of a cube's data source # YAXArrays.Cubes.Axes \u2014 Module . The Axes module handles the Axes of a data cube. It provides the following exports: CategoricalAxis CubeAxis RangeAxis getAxis source # YAXArrays.Cubes.Axes.CategoricalAxis \u2014 Type . struct CategoricalAxis { T , S , RT } To represent axes that are categorical, where T is the element type. The type parameter S denotes the axis name (a symbol). The default constructor is: CategoricalAxis(axname::String,values::Vector{T}) source # YAXArrays.Cubes.Axes.CubeAxis \u2014 Type . abstract type CubeAxis { T , S } Supertype of all axes. Every CubeAxis is an 1D Cube itself and can be passed to mapCube operations. In detail CubeAxis is an AbstractArray{Int, 1} source # YAXArrays.Cubes.Axes.RangeAxis \u2014 Type . RangeAxis { T , S , R } To represent axes that are numerical, where T is the element type. The type parameter S denotes the axis name (a symbol) and R the type of the range which is used to represent the axis values. The default constructor is: RangeAxis(axname::String,values::Range{T}) source # YAXArrays.Cubes.Axes.getAxis \u2014 Method . getAxis ( desc , c ) Given an Axis description and a cube, returns the corresponding axis of the cube. The Axis description can be: the name as a string or symbol. an Axis object source # YAXArrays.DAT.InDims \u2014 Type . InDims ( axisdesc ... ; ... ) Creates a description of an Input Data Cube for cube operations. Takes a single or multiple axis descriptions as first arguments. Alternatively a MovingWindow(@ref) struct can be passed to include neighbour slices of one or more axes in the computation. Axes can be specified by their name (String), through an Axis type, or by passing a concrete axis. Keyword arguments artype how shall the array be represented in the inner function. Defaults to Array , alternatives are DataFrame or AsAxisArray filter define some filter to skip the computation, e.g. when all values are missing. Defaults to AllMissing() , possible values are AnyMissing() , AnyOcean() , StdZero() , NValid(n) (for at least n non-missing elements). It is also possible to provide a custom one-argument function that takes the array and returns true if the compuation shall be skipped and false otherwise. window_oob_value if one of the input dimensions is a MowingWindow, this value will be used to fill out-of-bounds areas source # YAXArrays.DAT.MovingWindow \u2014 Type . MovingWindow ( desc , pre , after ) Constructs a MovingWindow object to be passed to an InDims constructor to define that the axis in desc shall participate in the inner function (i.e. shall be looped over), but inside the inner function pre values before and after values after the center value will be passed as well. For example passing MovingWindow(\"Time\", 2, 0) will loop over the time axis and always pass the current time step plus the 2 previous steps. So in the inner function the array will have an additional dimension of size 3. source # YAXArrays.DAT.OutDims \u2014 Method . OutDims ( axisdesc ; ... ) Creates a description of an Output Data Cube for cube operations. Takes a single or a Vector/Tuple of axes as first argument. Axes can be specified by their name (String), through an Axis type, or by passing a concrete axis. axisdesc : List of input axis names backend : specifies the dataset backend to write data to, must be either :auto or a key in YAXArrayBase.backendlist update : specifies wether the function operates inplace or if an output is returned artype : specifies the Array type inside the inner function that is mapped over chunksize : A Dict specifying the chunksizes for the output dimensions of the cube, or :input to copy chunksizes from input cube axes or :max to not chunk the inner dimensions outtype : force the output type to a specific type, defaults to Any which means that the element type of the first input cube is used source # YAXArrays.DAT.CubeTable \u2014 Method . CubeTable () Function to turn a DataCube object into an iterable table. Takes a list of as arguments, specified as a name=cube expression. For example CubeTable(data=cube1,country=cube2) would generate a Table with the entries data and country , where data contains the values of cube1 and country the values of cube2 . The cubes are matched and broadcasted along their axes like in mapCube . source # YAXArrays.DAT.cubefittable \u2014 Method . cubefittable ( tab , o , fitsym ; post = getpostfunction ( o ), kwargs ... ) Executes fittable on the CubeTable tab with the (Weighted-)OnlineStat o , looping through the values specified by fitsym . Finally, writes the results from the TableAggregator to an output data cube. source # YAXArrays.DAT.fittable \u2014 Method . fittable ( tab , o , fitsym ; by = (), weight = nothing ) Loops through an iterable table tab and thereby fitting an OnlineStat o with the values specified through fitsym . Optionally one can specify a field (or tuple) to group by. Any groupby specifier can either be a symbol denoting the entry to group by or an anynymous function calculating the group from a table row. For example the following would caluclate a weighted mean over a cube weighted by grid cell area and grouped by country and month: fittable ( iter , WeightedMean , :tair , weight = ( i -> abs ( cosd ( i . lat ))), by = ( i -> month ( i . time ), :country )) source # YAXArrays.DAT.mapCube \u2014 Method . mapCube ( fun , cube , addargs ... ; kwargs ... ) Map a given function `fun` over slices of all cubes of the dataset `ds` . Use InDims to discribe the input dimensions and OutDims to describe the output dimensions of the function . For Datasets , only one output cube can be specified . In contrast to the mapCube function for cubes , additional arguments for the inner function should be set as keyword arguments . For the specific keyword arguments see the docstring of the mapCube function for cubes . source # YAXArrays.DAT.mapCube \u2014 Method . mapCube ( fun , cube , addargs ... ; kwargs ... ) Map a given function fun over slices of the data cube cube . The additional arguments addargs will be forwarded to the inner function fun . Use InDims to discribe the input dimensions and OutDims to describe the output dimensions of the function. Keyword arguments max_cache=YAXDefaults.max_cache maximum size of blocks that are read into memory, defaults to approx 10Mb indims::InDims List of input cube descriptors of type InDims for each input data cube outdims::OutDims List of output cube descriptors of type OutDims for each output cube inplace does the function write to an output array inplace or return a single value> defaults to true ispar boolean to determine if parallelisation should be applied, defaults to true if workers are available. showprog boolean indicating if a ProgressMeter shall be shown include_loopvars boolean to indicate if the varoables looped over should be added as function arguments nthreads number of threads for the computation, defaults to Threads.nthreads for every worker. loopchunksize determines the chunk sizes of variables which are looped over, a dict kwargs additional keyword arguments are passed to the inner function The first argument is always the function to be applied, the second is the input cube or a tuple of input cubes if needed. source # YAXArrays.Datasets.Dataset \u2014 Method . Dataset(; properties = Dict{String,Any}, cubes...) Construct a YAXArray Dataset with global attributes properties a and a list of named YAXArrays cubes... source # YAXArrays.Datasets.Cube \u2014 Method . Cube ( ds :: Dataset ; joinname = \"Variable\" ) Construct a single YAXArray from the dataset ds by concatenating the cubes in the datset on the joinname dimension. source # YAXArrays.Datasets.savecube \u2014 Method . savecube ( cube , name :: String ) Save a YAXArray to the path . Extended Help The keyword arguments are: name : datasetaxis=\"Variable\" special treatment of a categorical axis that gets written into separate zarr arrays max_cache : The number of bits that are used as cache for the data handling. backend : The backend, that is used to save the data. Fallsback to searching the backend according to the extension of the path. driver overwrite::Bool=false overwrite cube if it already exists source # YAXArrays.Datasets.to_dataset \u2014 Method . to_dataset(c;datasetaxis = \"Variable\", name = \"layer\") Convert a Data Cube into a Dataset. It is possible to treat one of the Cube's axes as a \"DatasetAxis\" i.e. the cube will be split into different parts that become variables in the Dataset. If no such axis is specified or found, there will only be a single variable in the dataset with the name name source Internal API \u00a4 # YAXArrays.YAXDefaults \u2014 Constant . Default configuration for YAXArrays, has the following fields: workdir[]::String = \"./\" The default location for temporary cubes. recal[]::Bool = false set to true if you want @loadOrGenerate to always recalculate the results. chunksize[]::Any = :input Set the default output chunksize. max_cache[]::Float64 = 1e8 The maximum cache used by mapCube. cubedir[]::\"\" the default location for Cube() without an argument. subsetextensions::Array{Any} = [] List of registered functions, that convert subsetting input into dimension boundaries. source # YAXArrays.Cubes.CleanMe \u2014 Type . mutable struct CleanMe Struct which describes data paths and their persistency. Non-persistend paths/files are removed at finalize step source # YAXArrays.Cubes.clean \u2014 Method . clean ( c :: CleanMe ) finalizer function for CleanMe struct. The main process removes all directories/files which are not persistent. source # YAXArrays.Cubes.copydata \u2014 Method . copydata ( outar , inar , copybuf ) Internal function which copies the data from the input inar into the output outar at the copybuf positions. source # YAXArrays.Cubes.optifunc \u2014 Method . optifunc ( s , maxbuf , incs , outcs , insize , outsize , writefac ) Internal This function is going to be minimized to detect the best possible chunk setting for the rechunking of the data. source # YAXArrays.Cubes.Axes.abshalf \u2014 Method . abshalf source <a id='YAXArrays.Cubes.Axes.axVal2Index-Tuple{RangeAxis{<:Any, <:Any, <:AbstractRange}, Any}' href='#YAXArrays.Cubes.Axes.axVal2Index-Tuple{RangeAxis{<:Any, <:Any, <:AbstractRange}, Any}'># YAXArrays.Cubes.Axes.axVal2Index \u2014 Method . axVal2Index source # YAXArrays.Cubes.Axes.axVal2Index_lb \u2014 Method . axVal2Index_lb source # YAXArrays.Cubes.Axes.axVal2Index_ub \u2014 Method . axVal2Index_ub source # YAXArrays.Cubes.Axes.axcopy \u2014 Method . axcopy ( x , vals ) Makes a full copy of a CubeAxis with the values vals source # YAXArrays.Cubes.Axes.axisfrombb \u2014 Method . axisfrombb source <a id='YAXArrays.Cubes.Axes.axname-Union{Tuple{Type{<:CubeAxis{<:Any, U}}}, Tuple{U}} where U' href='#YAXArrays.Cubes.Axes.axname-Union{Tuple{Type{<:CubeAxis{<:Any, U}}}, Tuple{U}} where U'># YAXArrays.Cubes.Axes.axname \u2014 Method . axname source <a id='YAXArrays.Cubes.Axes.axsym-Union{Tuple{CubeAxis{<:Any, S}}, Tuple{S}} where S' href='#YAXArrays.Cubes.Axes.axsym-Union{Tuple{CubeAxis{<:Any, S}}, Tuple{S}} where S'># YAXArrays.Cubes.Axes.axsym \u2014 Method . axsym source <a id='YAXArrays.Cubes.Axes.convert_time-Tuple{Type{<:Dates.TimeType}, Dates.TimeType}' href='#YAXArrays.Cubes.Axes.convert_time-Tuple{Type{<:Dates.TimeType}, Dates.TimeType}'># YAXArrays.Cubes.Axes.convert_time \u2014 Method . convert_time source # YAXArrays.Cubes.Axes.findAxis \u2014 Method . findAxis ( desc , c ) Given an Axis description and a cube return the index of the Axis. The Axis description can be: the name as a string or symbol. an Axis object source # YAXArrays.Cubes.Axes.getOutAxis \u2014 Method . getOutAxis source # YAXArrays.Cubes.Axes.get_bb \u2014 Method . get_bb source # YAXArrays.Cubes.Axes.get_descriptor \u2014 Method . get_descriptor ( a ) Get the descriptor of an Axis. This is used to dispatch on the descriptor. source # YAXArrays.Cubes.Axes.get_step \u2014 Method . get_step returns stepwidth of the RangeAxis source # YAXArrays.Cubes.Axes.match_axis \u2014 Method . match_axis source <a id='YAXArrays.Cubes.Axes.renameaxis-Union{Tuple{V}, Tuple{T}, Tuple{RangeAxis{T, <:Any, V}, Any}} where {T, V}' href='#YAXArrays.Cubes.Axes.renameaxis-Union{Tuple{V}, Tuple{T}, Tuple{RangeAxis{T, <:Any, V}, Any}} where {T, V}'># YAXArrays.Cubes.Axes.renameaxis \u2014 Method . renameaxis source # YAXArrays.Cubes.caxes \u2014 Method . caxes Embeds Cube inside a new Cube source # YAXArrays.DAT.DATConfig \u2014 Type . Configuration object of a DAT process. This holds all necessary information to perform the calculations. It contains the following fields: incubes::Tuple{Vararg{YAXArrays.DAT.InputCube, NIN}} where NIN The input data cubes outcubes::Tuple{Vararg{YAXArrays.DAT.OutputCube, NOUT}} where NOUT The output data cubes allInAxes::Vector List of all axes of the input cubes LoopAxes::Vector List of axes that are looped through ispar::Bool Flag whether the computation is parallelized loopcachesize::Vector{Int64} allow_irregular_chunks::Bool max_cache::Any Maximal size of the in memory cache fu::Any Inner function which is computed inplace::Bool Flag whether the computation happens in place include_loopvars::Bool ntr::Any addargs::Any Additional arguments for the inner function kwargs::Any Additional keyword arguments for the inner function source # YAXArrays.DAT.InputCube \u2014 Type . Internal representation of an input cube for DAT operations cube The input data desc The input description given by the user/registration axesSmall List of axes that were actually selected through the description icolon colonperm loopinds Indices of loop axes that this cube does not contain, i.e. broadcasts cachesize Number of elements to keep in cache along each axis window iwindow windowloopinds iall source # YAXArrays.DAT.OutputCube \u2014 Type . Internal representation of an output cube for DAT operations Fields cube The actual outcube cube, once it is generated cube_unpermuted The unpermuted output cube desc The description of the output axes as given by users or registration axesSmall The list of output axes determined through the description allAxes List of all the axes of the cube loopinds Index of the loop axes that are broadcasted for this output cube innerchunks outtype Elementtype of the outputcube source # YAXArrays.DAT.YAXColumn \u2014 Type . YAXColumn A struct representing a single column of a YAXArray partitioned Table # Fields inarBC inds source # YAXArrays.DAT.cmpcachmisses \u2014 Method . Function that compares two cache miss specifiers by their importance source # YAXArrays.DAT.getFrontPerm \u2014 Method . Calculate an axis permutation that brings the wanted dimensions to the front source # YAXArrays.DAT.getLoopCacheSize \u2014 Method . Calculate optimal Cache size to DAT operation source # YAXArrays.DAT.getOuttype \u2014 Method . getOuttype ( outtype , cdata ) Internal function Get the element type for the output cube source # YAXArrays.DAT.getloopchunks \u2014 Method . getloopchunks ( dc :: DATConfig ) Internal function Returns the chunks that can be looped over toghether for all dimensions. This computation of the size of the chunks is handled by [`DiskArrays.approx_chunksize`](@ref) source # YAXArrays.DAT.permuteloopaxes \u2014 Method . permuteloopaxes ( dc ) Internal function Permute the dimensions of the cube, so that the axes that are looped through are in the first positions. This is necessary for a faster looping through the data. source # YAXArrays.Cubes.setchunks \u2014 Method . setchunks ( c :: Dataset , chunks ) Resets the chunks of all or a subset YAXArrays in the dataset and returns a new Dataset. Note that this will not change the chunking of the underlying data itself, it will just make the data \"look\" like it had a different chunking. If you need a persistent on-disk representation of this chunking, use savedataset on the resulting array. The chunks argument can take one of the following forms: a NamedTuple or AbstractDict mapping from variable name to a description of the desired variable chunks a NamedTuple or AbstractDict mapping from dimension name to a description of the desired variable chunks a description of the desired variable chunks applied to all members of the Dataset where a description of the desired variable chunks can take one of the following forms: a DiskArrays.GridChunks object a tuple specifying the chunk size along each dimension an AbstractDict or NamedTuple mapping one or more axis names to chunk sizes source # YAXArrays.Datasets.collectfromhandle \u2014 Method . Extracts a YAXArray from a dataset handle that was just created from a arrayinfo source # YAXArrays.Datasets.createdataset \u2014 Method . function createdataset(DS::Type,axlist; kwargs...) Creates a new dataset with axes specified in axlist . Each axis must be a subtype of CubeAxis . A new empty Zarr array will be created and can serve as a sink for mapCube operations. Keyword arguments path=\"\" location where the new cube is stored T=Union{Float32,Missing} data type of the target cube chunksize = ntuple(i->length(axlist[i]),length(axlist)) chunk sizes of the array chunkoffset = ntuple(i->0,length(axlist)) offsets of the chunks persist::Bool=true shall the disk data be garbage-collected when the cube goes out of scope? overwrite::Bool=false overwrite cube if it already exists properties=Dict{String,Any}() additional cube properties fillvalue= T>:Missing ? defaultfillval(Base.nonmissingtype(T)) : nothing fill value datasetaxis=\"Variable\" special treatment of a categorical axis that gets written into separate zarr arrays source # YAXArrays.Datasets.getarrayinfo \u2014 Method . Extract necessary information to create a YAXArrayBase dataset from a name and YAXArray pair source # YAXArrays.Datasets.testrange \u2014 Method . Test if data in x can be approximated by a step range source","title":"API"},{"location":"api/#public-api","text":"# YAXArrays.Cubes \u2014 Module . The functions provided by YAXArrays are supposed to work on different types of cubes. This module defines the interface for all Data types that source # YAXArrays.Cubes.YAXArray \u2014 Type . YAXArray { T , N } An array labelled with named axes that have values associated with them. It can wrap normal arrays or, more typically DiskArrays. Fields axes Vector{CubeAxis} containing the Axes of the Cube data length(axes)-dimensional array which holds the data, this can be a lazy DiskArray properties Metadata properties describing the content of the data chunks Representation of the chunking of the data cleaner Cleaner objects to track which objects to tidy up when the YAXArray goes out of scope source # YAXArrays.Cubes.caxes \u2014 Function . Returns the axes of a Cube source # YAXArrays.Cubes.concatenatecubes \u2014 Method . function concatenateCubes ( cubelist , cataxis :: CategoricalAxis ) Concatenates a vector of datacubes that have identical axes to a new single cube along the new axis cataxis source # YAXArrays.Cubes.readcubedata \u2014 Method . readcubedata ( cube ) Given any array implementing the YAXArray interface it returns an in-memory YAXArray from it. source # YAXArrays.Cubes.setchunks \u2014 Method . setchunks ( c :: YAXArray , chunks ) Resets the chunks of a YAXArray and returns a new YAXArray. Note that this will not change the chunking of the underlying data itself, it will just make the data \"look\" like it had a different chunking. If you need a persistent on-disk representation of this chunking, use savecube on the resulting array. The chunks argument can take one of the following forms: a DiskArrays.GridChunks object a tuple specifying the chunk size along each dimension an AbstractDict or NamedTuple mapping one or more axis names to chunk sizes source # YAXArrays.Cubes.subsetcube \u2014 Function . This function calculates a subset of a cube's data source # YAXArrays.Cubes.Axes \u2014 Module . The Axes module handles the Axes of a data cube. It provides the following exports: CategoricalAxis CubeAxis RangeAxis getAxis source # YAXArrays.Cubes.Axes.CategoricalAxis \u2014 Type . struct CategoricalAxis { T , S , RT } To represent axes that are categorical, where T is the element type. The type parameter S denotes the axis name (a symbol). The default constructor is: CategoricalAxis(axname::String,values::Vector{T}) source # YAXArrays.Cubes.Axes.CubeAxis \u2014 Type . abstract type CubeAxis { T , S } Supertype of all axes. Every CubeAxis is an 1D Cube itself and can be passed to mapCube operations. In detail CubeAxis is an AbstractArray{Int, 1} source # YAXArrays.Cubes.Axes.RangeAxis \u2014 Type . RangeAxis { T , S , R } To represent axes that are numerical, where T is the element type. The type parameter S denotes the axis name (a symbol) and R the type of the range which is used to represent the axis values. The default constructor is: RangeAxis(axname::String,values::Range{T}) source # YAXArrays.Cubes.Axes.getAxis \u2014 Method . getAxis ( desc , c ) Given an Axis description and a cube, returns the corresponding axis of the cube. The Axis description can be: the name as a string or symbol. an Axis object source # YAXArrays.DAT.InDims \u2014 Type . InDims ( axisdesc ... ; ... ) Creates a description of an Input Data Cube for cube operations. Takes a single or multiple axis descriptions as first arguments. Alternatively a MovingWindow(@ref) struct can be passed to include neighbour slices of one or more axes in the computation. Axes can be specified by their name (String), through an Axis type, or by passing a concrete axis. Keyword arguments artype how shall the array be represented in the inner function. Defaults to Array , alternatives are DataFrame or AsAxisArray filter define some filter to skip the computation, e.g. when all values are missing. Defaults to AllMissing() , possible values are AnyMissing() , AnyOcean() , StdZero() , NValid(n) (for at least n non-missing elements). It is also possible to provide a custom one-argument function that takes the array and returns true if the compuation shall be skipped and false otherwise. window_oob_value if one of the input dimensions is a MowingWindow, this value will be used to fill out-of-bounds areas source # YAXArrays.DAT.MovingWindow \u2014 Type . MovingWindow ( desc , pre , after ) Constructs a MovingWindow object to be passed to an InDims constructor to define that the axis in desc shall participate in the inner function (i.e. shall be looped over), but inside the inner function pre values before and after values after the center value will be passed as well. For example passing MovingWindow(\"Time\", 2, 0) will loop over the time axis and always pass the current time step plus the 2 previous steps. So in the inner function the array will have an additional dimension of size 3. source # YAXArrays.DAT.OutDims \u2014 Method . OutDims ( axisdesc ; ... ) Creates a description of an Output Data Cube for cube operations. Takes a single or a Vector/Tuple of axes as first argument. Axes can be specified by their name (String), through an Axis type, or by passing a concrete axis. axisdesc : List of input axis names backend : specifies the dataset backend to write data to, must be either :auto or a key in YAXArrayBase.backendlist update : specifies wether the function operates inplace or if an output is returned artype : specifies the Array type inside the inner function that is mapped over chunksize : A Dict specifying the chunksizes for the output dimensions of the cube, or :input to copy chunksizes from input cube axes or :max to not chunk the inner dimensions outtype : force the output type to a specific type, defaults to Any which means that the element type of the first input cube is used source # YAXArrays.DAT.CubeTable \u2014 Method . CubeTable () Function to turn a DataCube object into an iterable table. Takes a list of as arguments, specified as a name=cube expression. For example CubeTable(data=cube1,country=cube2) would generate a Table with the entries data and country , where data contains the values of cube1 and country the values of cube2 . The cubes are matched and broadcasted along their axes like in mapCube . source # YAXArrays.DAT.cubefittable \u2014 Method . cubefittable ( tab , o , fitsym ; post = getpostfunction ( o ), kwargs ... ) Executes fittable on the CubeTable tab with the (Weighted-)OnlineStat o , looping through the values specified by fitsym . Finally, writes the results from the TableAggregator to an output data cube. source # YAXArrays.DAT.fittable \u2014 Method . fittable ( tab , o , fitsym ; by = (), weight = nothing ) Loops through an iterable table tab and thereby fitting an OnlineStat o with the values specified through fitsym . Optionally one can specify a field (or tuple) to group by. Any groupby specifier can either be a symbol denoting the entry to group by or an anynymous function calculating the group from a table row. For example the following would caluclate a weighted mean over a cube weighted by grid cell area and grouped by country and month: fittable ( iter , WeightedMean , :tair , weight = ( i -> abs ( cosd ( i . lat ))), by = ( i -> month ( i . time ), :country )) source # YAXArrays.DAT.mapCube \u2014 Method . mapCube ( fun , cube , addargs ... ; kwargs ... ) Map a given function `fun` over slices of all cubes of the dataset `ds` . Use InDims to discribe the input dimensions and OutDims to describe the output dimensions of the function . For Datasets , only one output cube can be specified . In contrast to the mapCube function for cubes , additional arguments for the inner function should be set as keyword arguments . For the specific keyword arguments see the docstring of the mapCube function for cubes . source # YAXArrays.DAT.mapCube \u2014 Method . mapCube ( fun , cube , addargs ... ; kwargs ... ) Map a given function fun over slices of the data cube cube . The additional arguments addargs will be forwarded to the inner function fun . Use InDims to discribe the input dimensions and OutDims to describe the output dimensions of the function. Keyword arguments max_cache=YAXDefaults.max_cache maximum size of blocks that are read into memory, defaults to approx 10Mb indims::InDims List of input cube descriptors of type InDims for each input data cube outdims::OutDims List of output cube descriptors of type OutDims for each output cube inplace does the function write to an output array inplace or return a single value> defaults to true ispar boolean to determine if parallelisation should be applied, defaults to true if workers are available. showprog boolean indicating if a ProgressMeter shall be shown include_loopvars boolean to indicate if the varoables looped over should be added as function arguments nthreads number of threads for the computation, defaults to Threads.nthreads for every worker. loopchunksize determines the chunk sizes of variables which are looped over, a dict kwargs additional keyword arguments are passed to the inner function The first argument is always the function to be applied, the second is the input cube or a tuple of input cubes if needed. source # YAXArrays.Datasets.Dataset \u2014 Method . Dataset(; properties = Dict{String,Any}, cubes...) Construct a YAXArray Dataset with global attributes properties a and a list of named YAXArrays cubes... source # YAXArrays.Datasets.Cube \u2014 Method . Cube ( ds :: Dataset ; joinname = \"Variable\" ) Construct a single YAXArray from the dataset ds by concatenating the cubes in the datset on the joinname dimension. source # YAXArrays.Datasets.savecube \u2014 Method . savecube ( cube , name :: String ) Save a YAXArray to the path . Extended Help The keyword arguments are: name : datasetaxis=\"Variable\" special treatment of a categorical axis that gets written into separate zarr arrays max_cache : The number of bits that are used as cache for the data handling. backend : The backend, that is used to save the data. Fallsback to searching the backend according to the extension of the path. driver overwrite::Bool=false overwrite cube if it already exists source # YAXArrays.Datasets.to_dataset \u2014 Method . to_dataset(c;datasetaxis = \"Variable\", name = \"layer\") Convert a Data Cube into a Dataset. It is possible to treat one of the Cube's axes as a \"DatasetAxis\" i.e. the cube will be split into different parts that become variables in the Dataset. If no such axis is specified or found, there will only be a single variable in the dataset with the name name source","title":"Public API"},{"location":"api/#internal-api","text":"# YAXArrays.YAXDefaults \u2014 Constant . Default configuration for YAXArrays, has the following fields: workdir[]::String = \"./\" The default location for temporary cubes. recal[]::Bool = false set to true if you want @loadOrGenerate to always recalculate the results. chunksize[]::Any = :input Set the default output chunksize. max_cache[]::Float64 = 1e8 The maximum cache used by mapCube. cubedir[]::\"\" the default location for Cube() without an argument. subsetextensions::Array{Any} = [] List of registered functions, that convert subsetting input into dimension boundaries. source # YAXArrays.Cubes.CleanMe \u2014 Type . mutable struct CleanMe Struct which describes data paths and their persistency. Non-persistend paths/files are removed at finalize step source # YAXArrays.Cubes.clean \u2014 Method . clean ( c :: CleanMe ) finalizer function for CleanMe struct. The main process removes all directories/files which are not persistent. source # YAXArrays.Cubes.copydata \u2014 Method . copydata ( outar , inar , copybuf ) Internal function which copies the data from the input inar into the output outar at the copybuf positions. source # YAXArrays.Cubes.optifunc \u2014 Method . optifunc ( s , maxbuf , incs , outcs , insize , outsize , writefac ) Internal This function is going to be minimized to detect the best possible chunk setting for the rechunking of the data. source # YAXArrays.Cubes.Axes.abshalf \u2014 Method . abshalf source <a id='YAXArrays.Cubes.Axes.axVal2Index-Tuple{RangeAxis{<:Any, <:Any, <:AbstractRange}, Any}' href='#YAXArrays.Cubes.Axes.axVal2Index-Tuple{RangeAxis{<:Any, <:Any, <:AbstractRange}, Any}'># YAXArrays.Cubes.Axes.axVal2Index \u2014 Method . axVal2Index source # YAXArrays.Cubes.Axes.axVal2Index_lb \u2014 Method . axVal2Index_lb source # YAXArrays.Cubes.Axes.axVal2Index_ub \u2014 Method . axVal2Index_ub source # YAXArrays.Cubes.Axes.axcopy \u2014 Method . axcopy ( x , vals ) Makes a full copy of a CubeAxis with the values vals source # YAXArrays.Cubes.Axes.axisfrombb \u2014 Method . axisfrombb source <a id='YAXArrays.Cubes.Axes.axname-Union{Tuple{Type{<:CubeAxis{<:Any, U}}}, Tuple{U}} where U' href='#YAXArrays.Cubes.Axes.axname-Union{Tuple{Type{<:CubeAxis{<:Any, U}}}, Tuple{U}} where U'># YAXArrays.Cubes.Axes.axname \u2014 Method . axname source <a id='YAXArrays.Cubes.Axes.axsym-Union{Tuple{CubeAxis{<:Any, S}}, Tuple{S}} where S' href='#YAXArrays.Cubes.Axes.axsym-Union{Tuple{CubeAxis{<:Any, S}}, Tuple{S}} where S'># YAXArrays.Cubes.Axes.axsym \u2014 Method . axsym source <a id='YAXArrays.Cubes.Axes.convert_time-Tuple{Type{<:Dates.TimeType}, Dates.TimeType}' href='#YAXArrays.Cubes.Axes.convert_time-Tuple{Type{<:Dates.TimeType}, Dates.TimeType}'># YAXArrays.Cubes.Axes.convert_time \u2014 Method . convert_time source # YAXArrays.Cubes.Axes.findAxis \u2014 Method . findAxis ( desc , c ) Given an Axis description and a cube return the index of the Axis. The Axis description can be: the name as a string or symbol. an Axis object source # YAXArrays.Cubes.Axes.getOutAxis \u2014 Method . getOutAxis source # YAXArrays.Cubes.Axes.get_bb \u2014 Method . get_bb source # YAXArrays.Cubes.Axes.get_descriptor \u2014 Method . get_descriptor ( a ) Get the descriptor of an Axis. This is used to dispatch on the descriptor. source # YAXArrays.Cubes.Axes.get_step \u2014 Method . get_step returns stepwidth of the RangeAxis source # YAXArrays.Cubes.Axes.match_axis \u2014 Method . match_axis source <a id='YAXArrays.Cubes.Axes.renameaxis-Union{Tuple{V}, Tuple{T}, Tuple{RangeAxis{T, <:Any, V}, Any}} where {T, V}' href='#YAXArrays.Cubes.Axes.renameaxis-Union{Tuple{V}, Tuple{T}, Tuple{RangeAxis{T, <:Any, V}, Any}} where {T, V}'># YAXArrays.Cubes.Axes.renameaxis \u2014 Method . renameaxis source # YAXArrays.Cubes.caxes \u2014 Method . caxes Embeds Cube inside a new Cube source # YAXArrays.DAT.DATConfig \u2014 Type . Configuration object of a DAT process. This holds all necessary information to perform the calculations. It contains the following fields: incubes::Tuple{Vararg{YAXArrays.DAT.InputCube, NIN}} where NIN The input data cubes outcubes::Tuple{Vararg{YAXArrays.DAT.OutputCube, NOUT}} where NOUT The output data cubes allInAxes::Vector List of all axes of the input cubes LoopAxes::Vector List of axes that are looped through ispar::Bool Flag whether the computation is parallelized loopcachesize::Vector{Int64} allow_irregular_chunks::Bool max_cache::Any Maximal size of the in memory cache fu::Any Inner function which is computed inplace::Bool Flag whether the computation happens in place include_loopvars::Bool ntr::Any addargs::Any Additional arguments for the inner function kwargs::Any Additional keyword arguments for the inner function source # YAXArrays.DAT.InputCube \u2014 Type . Internal representation of an input cube for DAT operations cube The input data desc The input description given by the user/registration axesSmall List of axes that were actually selected through the description icolon colonperm loopinds Indices of loop axes that this cube does not contain, i.e. broadcasts cachesize Number of elements to keep in cache along each axis window iwindow windowloopinds iall source # YAXArrays.DAT.OutputCube \u2014 Type . Internal representation of an output cube for DAT operations Fields cube The actual outcube cube, once it is generated cube_unpermuted The unpermuted output cube desc The description of the output axes as given by users or registration axesSmall The list of output axes determined through the description allAxes List of all the axes of the cube loopinds Index of the loop axes that are broadcasted for this output cube innerchunks outtype Elementtype of the outputcube source # YAXArrays.DAT.YAXColumn \u2014 Type . YAXColumn A struct representing a single column of a YAXArray partitioned Table # Fields inarBC inds source # YAXArrays.DAT.cmpcachmisses \u2014 Method . Function that compares two cache miss specifiers by their importance source # YAXArrays.DAT.getFrontPerm \u2014 Method . Calculate an axis permutation that brings the wanted dimensions to the front source # YAXArrays.DAT.getLoopCacheSize \u2014 Method . Calculate optimal Cache size to DAT operation source # YAXArrays.DAT.getOuttype \u2014 Method . getOuttype ( outtype , cdata ) Internal function Get the element type for the output cube source # YAXArrays.DAT.getloopchunks \u2014 Method . getloopchunks ( dc :: DATConfig ) Internal function Returns the chunks that can be looped over toghether for all dimensions. This computation of the size of the chunks is handled by [`DiskArrays.approx_chunksize`](@ref) source # YAXArrays.DAT.permuteloopaxes \u2014 Method . permuteloopaxes ( dc ) Internal function Permute the dimensions of the cube, so that the axes that are looped through are in the first positions. This is necessary for a faster looping through the data. source # YAXArrays.Cubes.setchunks \u2014 Method . setchunks ( c :: Dataset , chunks ) Resets the chunks of all or a subset YAXArrays in the dataset and returns a new Dataset. Note that this will not change the chunking of the underlying data itself, it will just make the data \"look\" like it had a different chunking. If you need a persistent on-disk representation of this chunking, use savedataset on the resulting array. The chunks argument can take one of the following forms: a NamedTuple or AbstractDict mapping from variable name to a description of the desired variable chunks a NamedTuple or AbstractDict mapping from dimension name to a description of the desired variable chunks a description of the desired variable chunks applied to all members of the Dataset where a description of the desired variable chunks can take one of the following forms: a DiskArrays.GridChunks object a tuple specifying the chunk size along each dimension an AbstractDict or NamedTuple mapping one or more axis names to chunk sizes source # YAXArrays.Datasets.collectfromhandle \u2014 Method . Extracts a YAXArray from a dataset handle that was just created from a arrayinfo source # YAXArrays.Datasets.createdataset \u2014 Method . function createdataset(DS::Type,axlist; kwargs...) Creates a new dataset with axes specified in axlist . Each axis must be a subtype of CubeAxis . A new empty Zarr array will be created and can serve as a sink for mapCube operations. Keyword arguments path=\"\" location where the new cube is stored T=Union{Float32,Missing} data type of the target cube chunksize = ntuple(i->length(axlist[i]),length(axlist)) chunk sizes of the array chunkoffset = ntuple(i->0,length(axlist)) offsets of the chunks persist::Bool=true shall the disk data be garbage-collected when the cube goes out of scope? overwrite::Bool=false overwrite cube if it already exists properties=Dict{String,Any}() additional cube properties fillvalue= T>:Missing ? defaultfillval(Base.nonmissingtype(T)) : nothing fill value datasetaxis=\"Variable\" special treatment of a categorical axis that gets written into separate zarr arrays source # YAXArrays.Datasets.getarrayinfo \u2014 Method . Extract necessary information to create a YAXArrayBase dataset from a name and YAXArray pair source # YAXArrays.Datasets.testrange \u2014 Method . Test if data in x can be approximated by a step range source","title":"Internal API"},{"location":"examples/generated/Gallery/simplemaps/","text":"using Zarr , YAXArrays , Dates using GLMakie , GeoMakie using CairoMakie . GeometryBasics store = \"gs://cmip6/CMIP6/ScenarioMIP/DKRZ/MPI-ESM1-2-HR/ssp585/r1i1p1f1/3hr/tas/gn/v20190710/\" g = open_dataset ( zopen ( store , consolidated = true )) c = g [ \"tas\" ] YAXArray with the following dimensions lon Axis with 384 Elements from 0.0 to 359.0625 lat Axis with 192 Elements from -89.28422753251364 to 89.28422753251364 time Axis with 251288 Elements from 2015-01-01T03:00:00 to 2101-01-01T00:00:00 units: K name: tas Total size: 69.02 GB Subset, first time step ct1 = c [ time = Date ( \"2015-01-01\" )] lon = ct1 . lon lat = ct1 . lat data = ct1 . data [ : , : ]; Heatmap plot \u00a4 GLMakie . activate! () fig = Figure ( resolution = ( 1200 , 600 )) ax = Axis ( fig [ 1 , 1 ]; aspect = DataAspect ()) heatmap! ( ax , lon , lat , data ; colormap = :seaborn_icefire_gradient ) fig Add Coastlines via the GeoAxis, wintri Projection \u00a4 \u03b4lon = ( lon [ 2 ] - lon [ 1 ]) / 2 nlon = lon .- 180 .+ \u03b4lon ndata = circshift ( data , ( 192 , 1 )) GLMakie . activate! () fig = Figure ( resolution = ( 1200 , 600 )) ax = GeoAxis ( fig [ 1 , 1 ]) surface! ( ax , nlon , lat , ndata ; colormap = :seaborn_icefire_gradient , shading = false ) cl = lines! ( ax , GeoMakie . coastlines (), color = :white , linewidth = 0.85 ) translate! ( cl , 0 , 0 , 1000 ) fig Moll projection \u00a4 fig = Figure ( resolution = ( 1200 , 600 )) ax = GeoAxis ( fig [ 1 , 1 ]; dest = \"+proj=moll\" ) surface! ( ax , nlon , lat , ndata ; colormap = :seaborn_icefire_gradient , shading = false ) cl = lines! ( ax , GeoMakie . coastlines (), color = :white , linewidth = 0.85 ) translate! ( cl , 0 , 0 , 1000 ) fig 3D sphere plot \u00a4 #using JSServe, WGLMakie #WGLMakie.activate!() #Page(exportable=true, offline=true) ds = replace ( ndata , missing => NaN ) sphere = uv_normal_mesh ( Tesselation ( Sphere ( Point3f ( 0 ), 1 ), 128 )) fig = Figure () ax = LScene ( fig [ 1 , 1 ], show_axis = false ) mesh! ( ax , sphere ; color = ds ' [ end :- 1 : 1 , : ], colormap = :seaborn_icefire_gradient ) zoom! ( ax . scene , cameracontrols ( ax . scene ), 0.65 ) rotate! ( ax . scene , 2.5 ) fig This page was generated using Literate.jl .","title":"Simple maps"},{"location":"examples/generated/Gallery/simplemaps/#heatmap-plot","text":"GLMakie . activate! () fig = Figure ( resolution = ( 1200 , 600 )) ax = Axis ( fig [ 1 , 1 ]; aspect = DataAspect ()) heatmap! ( ax , lon , lat , data ; colormap = :seaborn_icefire_gradient ) fig","title":"Heatmap plot"},{"location":"examples/generated/Gallery/simplemaps/#add-coastlines-via-the-geoaxis-wintri-projection","text":"\u03b4lon = ( lon [ 2 ] - lon [ 1 ]) / 2 nlon = lon .- 180 .+ \u03b4lon ndata = circshift ( data , ( 192 , 1 )) GLMakie . activate! () fig = Figure ( resolution = ( 1200 , 600 )) ax = GeoAxis ( fig [ 1 , 1 ]) surface! ( ax , nlon , lat , ndata ; colormap = :seaborn_icefire_gradient , shading = false ) cl = lines! ( ax , GeoMakie . coastlines (), color = :white , linewidth = 0.85 ) translate! ( cl , 0 , 0 , 1000 ) fig","title":"Add Coastlines via the GeoAxis, wintri Projection"},{"location":"examples/generated/Gallery/simplemaps/#moll-projection","text":"fig = Figure ( resolution = ( 1200 , 600 )) ax = GeoAxis ( fig [ 1 , 1 ]; dest = \"+proj=moll\" ) surface! ( ax , nlon , lat , ndata ; colormap = :seaborn_icefire_gradient , shading = false ) cl = lines! ( ax , GeoMakie . coastlines (), color = :white , linewidth = 0.85 ) translate! ( cl , 0 , 0 , 1000 ) fig","title":"Moll projection"},{"location":"examples/generated/Gallery/simplemaps/#3d-sphere-plot","text":"#using JSServe, WGLMakie #WGLMakie.activate!() #Page(exportable=true, offline=true) ds = replace ( ndata , missing => NaN ) sphere = uv_normal_mesh ( Tesselation ( Sphere ( Point3f ( 0 ), 1 ), 128 )) fig = Figure () ax = LScene ( fig [ 1 , 1 ], show_axis = false ) mesh! ( ax , sphere ; color = ds ' [ end :- 1 : 1 , : ], colormap = :seaborn_icefire_gradient ) zoom! ( ax . scene , cameracontrols ( ax . scene ), 0.65 ) rotate! ( ax . scene , 2.5 ) fig This page was generated using Literate.jl .","title":"3D sphere plot"},{"location":"examples/generated/HowdoI/extract_axes_names/","text":"Question How do I extract the axes names from a Cube? using YAXArrays c = YAXArray ( rand ( 10 , 10 , 5 )) caxes ( c ) 3-element Vector{RangeAxis{Int64, _A, Base.OneTo{Int64}} where _A}: Dim_1 Axis with 10 Elements from 1 to 10 Dim_2 Axis with 10 Elements from 1 to 10 Dim_3 Axis with 5 Elements from 1 to 5 This page was generated using Literate.jl .","title":"Extract axes names"},{"location":"examples/generated/UserGuide/applyfunctions/","text":"How to apply functions on YAXArrays To apply user defined functions on a YAXArray data type we can use the map function, mapslices function or the mapCube function. Which of these functions should be used depends on the layout of the data, that the user defined function should be applied on. Apply a function on every element of a datacube \u00a4 The map function can be used to apply a function on every entry of a YAXArray without taking the dimensions into account. This will lazily register the mapped function which is applied when the YAXArray is either accessed or when more involved computations are made. #If we set up a dummy data cube which has all numbers between 1 and 10000. using YAXArrays axes = [ RangeAxis ( \"Lon\" , 1 : 10 ), RangeAxis ( \"Lat\" , 1 : 10 ), RangeAxis ( \"Time\" , 1 : 100 )] original = YAXArray ( axes , reshape ( 1 : 10000 , ( 10 , 10 , 100 ))) YAXArray with the following dimensions Lon Axis with 10 Elements from 1 to 10 Lat Axis with 10 Elements from 1 to 10 Time Axis with 100 Elements from 1 to 100 Total size: 78.12 KB with one at the first position: original [ 1 , : , 1 ] 10-element Vector{Int64}: 1 11 21 31 41 51 61 71 81 91 now we can substract 1 from all elements of this cube substracted = map ( x -> x - 1 , original ) YAXArray with the following dimensions Lon Axis with 10 Elements from 1 to 10 Lat Axis with 10 Elements from 1 to 10 Time Axis with 100 Elements from 1 to 100 Total size: 78.12 KB substracted is a cube of the same size as original , and the applied function is registered, so that it is applied as soon as the elements of substracted are either accessed or further used in other computations. substracted [ 1 , : , 1 ] 10-element Vector{Int64}: 0 10 20 30 40 50 60 70 80 90 Apply a function along dimensions of a single cube \u00a4 If an function should work along a certain dimension of the data you can use the 'mapslices' function to easily apply this function. This doesn't give you the flexibility of the mapCube function but it is easier to use for simple functions. If we set up a dummy data cube which has all numbers between 1 and 10000. axes = [ RangeAxis ( \"Lon\" , 1 : 10 ), RangeAxis ( \"Lat\" , 1 : 10 ), RangeAxis ( \"Time\" , 1 : 100 )] original = YAXArray ( axes , reshape ( 1 : 10000 , ( 10 , 10 , 100 ))) YAXArray with the following dimensions Lon Axis with 10 Elements from 1 to 10 Lat Axis with 10 Elements from 1 to 10 Time Axis with 100 Elements from 1 to 100 Total size: 78.12 KB and then we would like to compute the sum over the Time dimension: timesum = mapslices ( sum , original , dims = \"Time\" ) YAXArray with the following dimensions Lon Axis with 10 Elements from 1 to 10 Lat Axis with 10 Elements from 1 to 10 Total size: 800.0 bytes this reduces over the time dimension and gives us the following values timesum [ : , : ] 10\u00d710 Matrix{Union{Missing, Int64}}: 495100 496100 497100 498100 499100 \u2026 501100 502100 503100 504100 495200 496200 497200 498200 499200 501200 502200 503200 504200 495300 496300 497300 498300 499300 501300 502300 503300 504300 495400 496400 497400 498400 499400 501400 502400 503400 504400 495500 496500 497500 498500 499500 501500 502500 503500 504500 495600 496600 497600 498600 499600 \u2026 501600 502600 503600 504600 495700 496700 497700 498700 499700 501700 502700 503700 504700 495800 496800 497800 498800 499800 501800 502800 503800 504800 495900 496900 497900 498900 499900 501900 502900 503900 504900 496000 497000 498000 499000 500000 502000 503000 504000 505000 You can also apply a function along multiple dimensions of the same data cube. lonlatsum = mapslices ( sum , original , dims = ( \"Lon\" , \"Lat\" )) YAXArray with the following dimensions Time Axis with 100 Elements from 1 to 100 Total size: 800.0 bytes How to combine multiple cubes in one computation \u00a4 This page was generated using Literate.jl .","title":"Apply functions on YAXArrays"},{"location":"examples/generated/UserGuide/applyfunctions/#apply-a-function-on-every-element-of-a-datacube","text":"The map function can be used to apply a function on every entry of a YAXArray without taking the dimensions into account. This will lazily register the mapped function which is applied when the YAXArray is either accessed or when more involved computations are made. #If we set up a dummy data cube which has all numbers between 1 and 10000. using YAXArrays axes = [ RangeAxis ( \"Lon\" , 1 : 10 ), RangeAxis ( \"Lat\" , 1 : 10 ), RangeAxis ( \"Time\" , 1 : 100 )] original = YAXArray ( axes , reshape ( 1 : 10000 , ( 10 , 10 , 100 ))) YAXArray with the following dimensions Lon Axis with 10 Elements from 1 to 10 Lat Axis with 10 Elements from 1 to 10 Time Axis with 100 Elements from 1 to 100 Total size: 78.12 KB with one at the first position: original [ 1 , : , 1 ] 10-element Vector{Int64}: 1 11 21 31 41 51 61 71 81 91 now we can substract 1 from all elements of this cube substracted = map ( x -> x - 1 , original ) YAXArray with the following dimensions Lon Axis with 10 Elements from 1 to 10 Lat Axis with 10 Elements from 1 to 10 Time Axis with 100 Elements from 1 to 100 Total size: 78.12 KB substracted is a cube of the same size as original , and the applied function is registered, so that it is applied as soon as the elements of substracted are either accessed or further used in other computations. substracted [ 1 , : , 1 ] 10-element Vector{Int64}: 0 10 20 30 40 50 60 70 80 90","title":"Apply a function on every element of a datacube"},{"location":"examples/generated/UserGuide/applyfunctions/#apply-a-function-along-dimensions-of-a-single-cube","text":"If an function should work along a certain dimension of the data you can use the 'mapslices' function to easily apply this function. This doesn't give you the flexibility of the mapCube function but it is easier to use for simple functions. If we set up a dummy data cube which has all numbers between 1 and 10000. axes = [ RangeAxis ( \"Lon\" , 1 : 10 ), RangeAxis ( \"Lat\" , 1 : 10 ), RangeAxis ( \"Time\" , 1 : 100 )] original = YAXArray ( axes , reshape ( 1 : 10000 , ( 10 , 10 , 100 ))) YAXArray with the following dimensions Lon Axis with 10 Elements from 1 to 10 Lat Axis with 10 Elements from 1 to 10 Time Axis with 100 Elements from 1 to 100 Total size: 78.12 KB and then we would like to compute the sum over the Time dimension: timesum = mapslices ( sum , original , dims = \"Time\" ) YAXArray with the following dimensions Lon Axis with 10 Elements from 1 to 10 Lat Axis with 10 Elements from 1 to 10 Total size: 800.0 bytes this reduces over the time dimension and gives us the following values timesum [ : , : ] 10\u00d710 Matrix{Union{Missing, Int64}}: 495100 496100 497100 498100 499100 \u2026 501100 502100 503100 504100 495200 496200 497200 498200 499200 501200 502200 503200 504200 495300 496300 497300 498300 499300 501300 502300 503300 504300 495400 496400 497400 498400 499400 501400 502400 503400 504400 495500 496500 497500 498500 499500 501500 502500 503500 504500 495600 496600 497600 498600 499600 \u2026 501600 502600 503600 504600 495700 496700 497700 498700 499700 501700 502700 503700 504700 495800 496800 497800 498800 499800 501800 502800 503800 504800 495900 496900 497900 498900 499900 501900 502900 503900 504900 496000 497000 498000 499000 500000 502000 503000 504000 505000 You can also apply a function along multiple dimensions of the same data cube. lonlatsum = mapslices ( sum , original , dims = ( \"Lon\" , \"Lat\" )) YAXArray with the following dimensions Time Axis with 100 Elements from 1 to 100 Total size: 800.0 bytes","title":"Apply a function along dimensions of a single cube"},{"location":"examples/generated/UserGuide/applyfunctions/#how-to-combine-multiple-cubes-in-one-computation","text":"This page was generated using Literate.jl .","title":"How to combine multiple cubes in one computation"},{"location":"examples/generated/UserGuide/creating/","text":"Creating YAXArrays and Datasets \u00a4 Creating a YAXArray \u00a4 using YAXArrays a = YAXArray ( rand ( 10 , 20 , 5 )) YAXArray with the following dimensions Dim_1 Axis with 10 Elements from 1 to 10 Dim_2 Axis with 20 Elements from 1 to 20 Dim_3 Axis with 5 Elements from 1 to 5 Total size: 7.81 KB if not names are defined then default ones will be used, i.e. Dim_1 , Dim_2 . Get data from each Dimension with a . Dim_1 10-element RangeAxis{Int64, :Dim_1, Base.OneTo{Int64}}: 1 2 3 4 5 6 7 8 9 10 or with getproperty ( a , :Dim_1 ) 10-element RangeAxis{Int64, :Dim_1, Base.OneTo{Int64}}: 1 2 3 4 5 6 7 8 9 10 Creating a YAXArray with named axis \u00a4 The two most used axis are RangeAxis and CategoricalAxis . Here, we use a combination of them to create a time , lon and lat axis and a Categorical Axis for two variables. Axis definitions \u00a4 using Dates axlist = [ RangeAxis ( \"time\" , Date ( \"2022-01-01\" ) : Day ( 1 ) : Date ( \"2022-01-30\" )), RangeAxis ( \"lon\" , range ( 1 , 10 , length = 10 )), RangeAxis ( \"lat\" , range ( 1 , 5 , length = 15 )), CategoricalAxis ( \"Variable\" , [ \"var1\" , \"var2\" ]) ] 4-element Vector{CubeAxis}: time Axis with 30 Elements from 2022-01-01 to 2022-01-30 lon Axis with 10 Elements from 1.0 to 10.0 lat Axis with 15 Elements from 1.0 to 5.0 Variable Axis with 2 elements: var1 var2 And the corresponding data data = rand ( 30 , 10 , 15 , 2 ) ds = YAXArray ( axlist , data ) YAXArray with the following dimensions time Axis with 30 Elements from 2022-01-01 to 2022-01-30 lon Axis with 10 Elements from 1.0 to 10.0 lat Axis with 15 Elements from 1.0 to 5.0 Variable Axis with 2 elements: var1 var2 Total size: 70.31 KB Select variables \u00a4 ds [ Variable = \"var1\" , lon = ( 1 , 2.1 )] YAXArray with the following dimensions time Axis with 30 Elements from 2022-01-01 to 2022-01-30 lon Axis with 2 Elements from 1.0 to 2.0 lat Axis with 15 Elements from 1.0 to 5.0 Total size: 7.03 KB Indexing and subsetting \u00a4 As for most array types, YAXArray also provides special indexing behavior when using the square brackets for indexing. Assuming that c is a YAXArray, there are 3 different semantics to use the square brackets with, depending on the types of the arguments provided to getindex. Ranges and Integers only as for example c[1,4:8,:] will access the underlying data according to the provided index in index space and read the data into memory as a plain Julia Array. It is equivalent to c.data[1,4:8,:] . Keyword arguments with values or Intervals as for example c[longitude = 30..50, time=Date(2005,6,1), variable=\"air_temperature\"] . This always creates a view into the specified subset of the data and return a new YAXArray with new axes without reading the data. Intervals and values are always interpreted in the units as provided by the axis values. A Tables.jl-compatible object for irregular extraction of a list of points or sub-arrays and random locations. For example calling c[[(lon=30,lat=42),(lon=-50,lat=2.5)]] will extract data at the specified coordinates and along all additional axes into memory. It returns a new YAXArray with a new Multi-Index axis along the selected longitudes and latitudes. Info Overall, selecting elements in YAXArrays is brittle. Hence using DimensionalData.jl and YAXArrayBase.jl is recomended. Select variables with DimensionalData.jl \u00a4 using DimensionalData , YAXArrayBase First we wrap the yaxarray into a DimArray via dim = yaxconvert ( DimArray , ds ) 30\u00d710\u00d715\u00d72 DimArray{Float64,4} with dimensions: Dim{:time} Sampled{Date} Date(\"2022-01-01\"):Dates.Day(1):Date(\"2022-01-30\") ForwardOrdered Regular Points, Dim{:lon} Sampled{Float64} 1.0:1.0:10.0 ForwardOrdered Regular Points, Dim{:lat} Sampled{Float64} 1.0:0.2857142857142857:5.0 ForwardOrdered Regular Points, Dim{:Variable} Categorical{String} String[var1, var2] ForwardOrdered [:, :, 1, 1] 1.0 \u2026 8.0 9.0 10.0 2022-01-01 0.0112041 0.434277 0.115346 0.141662 2022-01-02 0.956596 0.723423 0.814847 0.354198 2022-01-03 0.159402 0.441245 0.654139 0.0925121 2022-01-04 0.741865 0.890633 0.481478 0.715789 \u22ee \u22f1 \u22ee 2022-01-26 0.391335 0.446051 0.598266 0.367645 2022-01-27 0.488404 0.738037 0.669385 0.659778 2022-01-28 0.624435 0.16211 0.348644 0.335912 2022-01-29 0.68089 0.00400632 0.170599 0.287097 2022-01-30 0.361055 \u2026 0.794405 0.446556 0.928772 [and 29 more slices...] Now, the syntax from DimensionalData.jl just works subset = dim [ time = Between ( Date ( \"2022-01-01\" ), Date ( \"2022-01-10\" )), lon = Between ( 1 , 2 ), Variable = At ( \"var2\" ) ] 10\u00d72\u00d715 DimArray{Float64,3} with dimensions: Dim{:time} Sampled{Date} Date(\"2022-01-01\"):Dates.Day(1):Date(\"2022-01-10\") ForwardOrdered Regular Points, Dim{:lon} Sampled{Float64} 1.0:1.0:2.0 ForwardOrdered Regular Points, Dim{:lat} Sampled{Float64} 1.0:0.2857142857142857:5.0 ForwardOrdered Regular Points and reference dimensions: Dim{:Variable} Categorical{String} String[var2] ForwardOrdered [:, :, 1] 1.0 2.0 2022-01-01 0.989484 0.828273 2022-01-02 0.784253 0.0733046 2022-01-03 0.968372 0.310392 2022-01-04 0.341495 0.919374 \u22ee 2022-01-07 0.845265 0.79126 2022-01-08 0.259922 0.139034 2022-01-09 0.29941 0.0626658 2022-01-10 0.191306 0.444613 [and 14 more slices...] And going back to our YAXArray view is done with yax = yaxconvert ( YAXArray , subset ) YAXArray with the following dimensions time Axis with 10 Elements from 2022-01-01 to 2022-01-10 lon Axis with 2 Elements from 1.0 to 2.0 lat Axis with 15 Elements from 1.0 to 5.0 Total size: 2.34 KB This will be supported by default in the next release. Properties / Attributes \u00a4 You might also want to add additional properties to your YAXArray. This can be done via a Dictionary, namely props = Dict ( \"time\" => \"days\" , \"lon\" => \"longitude\" , \"lat\" => \"latitude\" , \"var1\" => \"first variable\" , \"var2\" => \"second variable\" , ) Dict{String, String} with 5 entries: \"lat\" => \"latitude\" \"var1\" => \"first variable\" \"time\" => \"days\" \"var2\" => \"second variable\" \"lon\" => \"longitude\" Then the yaxarray with properties is assemble with ds = YAXArray ( axlist , data , props ) YAXArray with the following dimensions time Axis with 30 Elements from 2022-01-01 to 2022-01-30 lon Axis with 10 Elements from 1.0 to 10.0 lat Axis with 15 Elements from 1.0 to 5.0 Variable Axis with 2 elements: var1 var2 Total size: 70.31 KB Access these properties with ds . properties Dict{String, String} with 5 entries: \"lat\" => \"latitude\" \"var1\" => \"first variable\" \"time\" => \"days\" \"var2\" => \"second variable\" \"lon\" => \"longitude\" Note that this properties are shared for both variables var1 and var2 . Namely, this are global properties for your yaxarray. However, in most cases you will want to pass properties for each variable, here we will do this via Datasets. Creating a Dataset \u00a4 Let's define first some range axis axs = [ RangeAxis ( \"lon\" , range ( 0 , 1 , length = 10 )), RangeAxis ( \"lat\" , range ( 0 , 1 , length = 5 )), ] 2-element Vector{RangeAxis{Float64, S, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}} where S}: lon Axis with 10 Elements from 0.0 to 1.0 lat Axis with 5 Elements from 0.0 to 1.0 And two toy random YAXArrays to assemble our dataset t2m = YAXArray ( axs , rand ( 10 , 5 ), Dict ( \"units\" => \"K\" , \"reference\" => \"your references\" )) prec = YAXArray ( axs , rand ( 10 , 5 ), Dict ( \"units\" => \"mm\" , \"reference\" => \"your references\" )) ds = Dataset ( t2m = t2m , prec = prec , num = YAXArray ( rand ( 10 )), properties = Dict ( \"space\" => \"lon/lat\" , \"reference\" => \"your global references\" )) YAXArray Dataset Dimensions: lat Axis with 5 Elements from 0.0 to 1.0 Dim_1 Axis with 10 Elements from 1 to 10 lon Axis with 10 Elements from 0.0 to 1.0 Variables: t2m prec num Properties: reference => your global references space => lon/lat Note that the YAXArrays used not necessarily shared the same dimensions. Hence, using a Dataset if more versatile than a plain YAXArray. Selected Variables into a Data Cube \u00a4 Being able to collect variables that share dimensions into a data cube is possible with c = Cube ( ds [[ \"t2m\" , \"prec\" ]]) YAXArray with the following dimensions lon Axis with 10 Elements from 0.0 to 1.0 lat Axis with 5 Elements from 0.0 to 1.0 Variable Axis with 2 elements: t2m prec units: mm Total size: 800.0 bytes or simply the one that does not share all dimensions Cube ( ds [[ \"num\" ]]) YAXArray with the following dimensions Dim_1 Axis with 10 Elements from 1 to 10 Total size: 80.0 bytes Variable properties \u00a4 # Access to variables properties is done via Cube ( ds [[ \"t2m\" ]]) . properties Dict{String, String} with 2 entries: \"units\" => \"K\" \"reference\" => \"your references\" and Cube ( ds [[ \"prec\" ]]) . properties Dict{String, String} with 2 entries: \"units\" => \"mm\" \"reference\" => \"your references\" Note also that the global properties for the Dataset are accessed with ds . properties Dict{String, String} with 2 entries: \"reference\" => \"your global references\" \"space\" => \"lon/lat\" Saving and different chunking modes are discussed in here . This page was generated using Literate.jl .","title":"Creating YAXArrays and Datasets"},{"location":"examples/generated/UserGuide/creating/#creating-yaxarrays-and-datasets","text":"","title":"Creating YAXArrays and Datasets"},{"location":"examples/generated/UserGuide/creating/#creating-a-yaxarray","text":"using YAXArrays a = YAXArray ( rand ( 10 , 20 , 5 )) YAXArray with the following dimensions Dim_1 Axis with 10 Elements from 1 to 10 Dim_2 Axis with 20 Elements from 1 to 20 Dim_3 Axis with 5 Elements from 1 to 5 Total size: 7.81 KB if not names are defined then default ones will be used, i.e. Dim_1 , Dim_2 . Get data from each Dimension with a . Dim_1 10-element RangeAxis{Int64, :Dim_1, Base.OneTo{Int64}}: 1 2 3 4 5 6 7 8 9 10 or with getproperty ( a , :Dim_1 ) 10-element RangeAxis{Int64, :Dim_1, Base.OneTo{Int64}}: 1 2 3 4 5 6 7 8 9 10","title":"Creating a YAXArray"},{"location":"examples/generated/UserGuide/creating/#creating-a-yaxarray-with-named-axis","text":"The two most used axis are RangeAxis and CategoricalAxis . Here, we use a combination of them to create a time , lon and lat axis and a Categorical Axis for two variables.","title":"Creating a YAXArray with named axis"},{"location":"examples/generated/UserGuide/creating/#axis-definitions","text":"using Dates axlist = [ RangeAxis ( \"time\" , Date ( \"2022-01-01\" ) : Day ( 1 ) : Date ( \"2022-01-30\" )), RangeAxis ( \"lon\" , range ( 1 , 10 , length = 10 )), RangeAxis ( \"lat\" , range ( 1 , 5 , length = 15 )), CategoricalAxis ( \"Variable\" , [ \"var1\" , \"var2\" ]) ] 4-element Vector{CubeAxis}: time Axis with 30 Elements from 2022-01-01 to 2022-01-30 lon Axis with 10 Elements from 1.0 to 10.0 lat Axis with 15 Elements from 1.0 to 5.0 Variable Axis with 2 elements: var1 var2 And the corresponding data data = rand ( 30 , 10 , 15 , 2 ) ds = YAXArray ( axlist , data ) YAXArray with the following dimensions time Axis with 30 Elements from 2022-01-01 to 2022-01-30 lon Axis with 10 Elements from 1.0 to 10.0 lat Axis with 15 Elements from 1.0 to 5.0 Variable Axis with 2 elements: var1 var2 Total size: 70.31 KB","title":"Axis definitions"},{"location":"examples/generated/UserGuide/creating/#select-variables","text":"ds [ Variable = \"var1\" , lon = ( 1 , 2.1 )] YAXArray with the following dimensions time Axis with 30 Elements from 2022-01-01 to 2022-01-30 lon Axis with 2 Elements from 1.0 to 2.0 lat Axis with 15 Elements from 1.0 to 5.0 Total size: 7.03 KB","title":"Select variables"},{"location":"examples/generated/UserGuide/creating/#indexing-and-subsetting","text":"As for most array types, YAXArray also provides special indexing behavior when using the square brackets for indexing. Assuming that c is a YAXArray, there are 3 different semantics to use the square brackets with, depending on the types of the arguments provided to getindex. Ranges and Integers only as for example c[1,4:8,:] will access the underlying data according to the provided index in index space and read the data into memory as a plain Julia Array. It is equivalent to c.data[1,4:8,:] . Keyword arguments with values or Intervals as for example c[longitude = 30..50, time=Date(2005,6,1), variable=\"air_temperature\"] . This always creates a view into the specified subset of the data and return a new YAXArray with new axes without reading the data. Intervals and values are always interpreted in the units as provided by the axis values. A Tables.jl-compatible object for irregular extraction of a list of points or sub-arrays and random locations. For example calling c[[(lon=30,lat=42),(lon=-50,lat=2.5)]] will extract data at the specified coordinates and along all additional axes into memory. It returns a new YAXArray with a new Multi-Index axis along the selected longitudes and latitudes. Info Overall, selecting elements in YAXArrays is brittle. Hence using DimensionalData.jl and YAXArrayBase.jl is recomended.","title":"Indexing and subsetting"},{"location":"examples/generated/UserGuide/creating/#select-variables-with-dimensionaldatajl","text":"using DimensionalData , YAXArrayBase First we wrap the yaxarray into a DimArray via dim = yaxconvert ( DimArray , ds ) 30\u00d710\u00d715\u00d72 DimArray{Float64,4} with dimensions: Dim{:time} Sampled{Date} Date(\"2022-01-01\"):Dates.Day(1):Date(\"2022-01-30\") ForwardOrdered Regular Points, Dim{:lon} Sampled{Float64} 1.0:1.0:10.0 ForwardOrdered Regular Points, Dim{:lat} Sampled{Float64} 1.0:0.2857142857142857:5.0 ForwardOrdered Regular Points, Dim{:Variable} Categorical{String} String[var1, var2] ForwardOrdered [:, :, 1, 1] 1.0 \u2026 8.0 9.0 10.0 2022-01-01 0.0112041 0.434277 0.115346 0.141662 2022-01-02 0.956596 0.723423 0.814847 0.354198 2022-01-03 0.159402 0.441245 0.654139 0.0925121 2022-01-04 0.741865 0.890633 0.481478 0.715789 \u22ee \u22f1 \u22ee 2022-01-26 0.391335 0.446051 0.598266 0.367645 2022-01-27 0.488404 0.738037 0.669385 0.659778 2022-01-28 0.624435 0.16211 0.348644 0.335912 2022-01-29 0.68089 0.00400632 0.170599 0.287097 2022-01-30 0.361055 \u2026 0.794405 0.446556 0.928772 [and 29 more slices...] Now, the syntax from DimensionalData.jl just works subset = dim [ time = Between ( Date ( \"2022-01-01\" ), Date ( \"2022-01-10\" )), lon = Between ( 1 , 2 ), Variable = At ( \"var2\" ) ] 10\u00d72\u00d715 DimArray{Float64,3} with dimensions: Dim{:time} Sampled{Date} Date(\"2022-01-01\"):Dates.Day(1):Date(\"2022-01-10\") ForwardOrdered Regular Points, Dim{:lon} Sampled{Float64} 1.0:1.0:2.0 ForwardOrdered Regular Points, Dim{:lat} Sampled{Float64} 1.0:0.2857142857142857:5.0 ForwardOrdered Regular Points and reference dimensions: Dim{:Variable} Categorical{String} String[var2] ForwardOrdered [:, :, 1] 1.0 2.0 2022-01-01 0.989484 0.828273 2022-01-02 0.784253 0.0733046 2022-01-03 0.968372 0.310392 2022-01-04 0.341495 0.919374 \u22ee 2022-01-07 0.845265 0.79126 2022-01-08 0.259922 0.139034 2022-01-09 0.29941 0.0626658 2022-01-10 0.191306 0.444613 [and 14 more slices...] And going back to our YAXArray view is done with yax = yaxconvert ( YAXArray , subset ) YAXArray with the following dimensions time Axis with 10 Elements from 2022-01-01 to 2022-01-10 lon Axis with 2 Elements from 1.0 to 2.0 lat Axis with 15 Elements from 1.0 to 5.0 Total size: 2.34 KB This will be supported by default in the next release.","title":"Select variables with DimensionalData.jl"},{"location":"examples/generated/UserGuide/creating/#properties-attributes","text":"You might also want to add additional properties to your YAXArray. This can be done via a Dictionary, namely props = Dict ( \"time\" => \"days\" , \"lon\" => \"longitude\" , \"lat\" => \"latitude\" , \"var1\" => \"first variable\" , \"var2\" => \"second variable\" , ) Dict{String, String} with 5 entries: \"lat\" => \"latitude\" \"var1\" => \"first variable\" \"time\" => \"days\" \"var2\" => \"second variable\" \"lon\" => \"longitude\" Then the yaxarray with properties is assemble with ds = YAXArray ( axlist , data , props ) YAXArray with the following dimensions time Axis with 30 Elements from 2022-01-01 to 2022-01-30 lon Axis with 10 Elements from 1.0 to 10.0 lat Axis with 15 Elements from 1.0 to 5.0 Variable Axis with 2 elements: var1 var2 Total size: 70.31 KB Access these properties with ds . properties Dict{String, String} with 5 entries: \"lat\" => \"latitude\" \"var1\" => \"first variable\" \"time\" => \"days\" \"var2\" => \"second variable\" \"lon\" => \"longitude\" Note that this properties are shared for both variables var1 and var2 . Namely, this are global properties for your yaxarray. However, in most cases you will want to pass properties for each variable, here we will do this via Datasets.","title":"Properties / Attributes"},{"location":"examples/generated/UserGuide/creating/#creating-a-dataset","text":"Let's define first some range axis axs = [ RangeAxis ( \"lon\" , range ( 0 , 1 , length = 10 )), RangeAxis ( \"lat\" , range ( 0 , 1 , length = 5 )), ] 2-element Vector{RangeAxis{Float64, S, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}} where S}: lon Axis with 10 Elements from 0.0 to 1.0 lat Axis with 5 Elements from 0.0 to 1.0 And two toy random YAXArrays to assemble our dataset t2m = YAXArray ( axs , rand ( 10 , 5 ), Dict ( \"units\" => \"K\" , \"reference\" => \"your references\" )) prec = YAXArray ( axs , rand ( 10 , 5 ), Dict ( \"units\" => \"mm\" , \"reference\" => \"your references\" )) ds = Dataset ( t2m = t2m , prec = prec , num = YAXArray ( rand ( 10 )), properties = Dict ( \"space\" => \"lon/lat\" , \"reference\" => \"your global references\" )) YAXArray Dataset Dimensions: lat Axis with 5 Elements from 0.0 to 1.0 Dim_1 Axis with 10 Elements from 1 to 10 lon Axis with 10 Elements from 0.0 to 1.0 Variables: t2m prec num Properties: reference => your global references space => lon/lat Note that the YAXArrays used not necessarily shared the same dimensions. Hence, using a Dataset if more versatile than a plain YAXArray.","title":"Creating a Dataset"},{"location":"examples/generated/UserGuide/creating/#selected-variables-into-a-data-cube","text":"Being able to collect variables that share dimensions into a data cube is possible with c = Cube ( ds [[ \"t2m\" , \"prec\" ]]) YAXArray with the following dimensions lon Axis with 10 Elements from 0.0 to 1.0 lat Axis with 5 Elements from 0.0 to 1.0 Variable Axis with 2 elements: t2m prec units: mm Total size: 800.0 bytes or simply the one that does not share all dimensions Cube ( ds [[ \"num\" ]]) YAXArray with the following dimensions Dim_1 Axis with 10 Elements from 1 to 10 Total size: 80.0 bytes","title":"Selected Variables into a Data Cube"},{"location":"examples/generated/UserGuide/creating/#variable-properties","text":"# Access to variables properties is done via Cube ( ds [[ \"t2m\" ]]) . properties Dict{String, String} with 2 entries: \"units\" => \"K\" \"reference\" => \"your references\" and Cube ( ds [[ \"prec\" ]]) . properties Dict{String, String} with 2 entries: \"units\" => \"mm\" \"reference\" => \"your references\" Note also that the global properties for the Dataset are accessed with ds . properties Dict{String, String} with 2 entries: \"reference\" => \"your global references\" \"space\" => \"lon/lat\" Saving and different chunking modes are discussed in here . This page was generated using Literate.jl .","title":"Variable properties"},{"location":"examples/generated/UserGuide/distributed/","text":"How to calculate a time mean \u00a4 using YAXArrays , Statistics , Zarr using Dates axlist = [ RangeAxis ( \"time\" , Date ( \"2022-01-01\" ) : Day ( 1 ) : Date ( \"2022-01-30\" )), RangeAxis ( \"lon\" , range ( 1 , 10 , length = 10 )), RangeAxis ( \"lat\" , range ( 1 , 5 , length = 15 )), CategoricalAxis ( \"Variable\" , [ \"var1\" , \"var2\" ]) ] 4-element Vector{CubeAxis}: time Axis with 30 Elements from 2022-01-01 to 2022-01-30 lon Axis with 10 Elements from 1.0 to 10.0 lat Axis with 15 Elements from 1.0 to 5.0 Variable Axis with 2 elements: var1 var2 And the corresponding data data = rand ( 30 , 10 , 15 , 2 ) ds = YAXArray ( axlist , data ) c = ds [ Variable = \"var1\" ] # see OpenNetCDF to get the file mapslices ( mean \u2218 skipmissing , c , dims = \"Time\" ) YAXArray with the following dimensions lon Axis with 10 Elements from 1.0 to 10.0 lat Axis with 15 Elements from 1.0 to 5.0 Total size: 1.17 KB Distributed calculations \u00a4 It is possible to distribute the calculations over multiple process. The following code does a time mean over all grid points using multiple CPU over a local machine. #using Distributed #addprocs(2) #@everywhere using Pkg #@everywhere Pkg.activate(\".\") #@everywhere begin using NetCDF using YAXArrays using Statistics using Zarr #end #@everywhere function mymean(output, pixel) @show \"doing a mean\" output[:] .= mean(pixel) #end #indims = InDims(\"time\") #outdims = OutDims() #resultcube = mapCube(mymean, c, indims=indims, outdims=outdims) In the last example, mapCube was used to map the mymean function. mapslices is a convenient function that can replace mapCube , where you can omit defining an extra function with the output argument as an input (e.g. mymean ). It is possible to simply use mapslice resultcube = mapslices ( mean \u2218 skipmissing , c , dims = \"time\" ) YAXArray with the following dimensions lon Axis with 10 Elements from 1.0 to 10.0 lat Axis with 15 Elements from 1.0 to 5.0 Total size: 1.17 KB SLURM cluster \u00a4 It is also possible to distribute easily the workload on a cluster, with little modification to the code. The following code does a time mean over all grid points using multiple CPU over a SLURM cluster. To do so, we use the ClusterManagers package. #using Distributed #using ClusterManagers #addprocs(SlurmManager(10)) #@everywhere using Pkg #@everywhere Pkg.activate(\".\") #@everywhere using ESDL #@everywhere using Statistics #inpath=\"zg1000_AERday_CanESM5_esm-hist_r6i1p1f1_gn_18500101-20141231.nc\" #c = Cube(inpath, \"zg1000\") #resultcube = mapslices(mean \u2218 skipmissing, c, dims=\"time\") This page was generated using Literate.jl .","title":"Distributed processes"},{"location":"examples/generated/UserGuide/distributed/#how-to-calculate-a-time-mean","text":"using YAXArrays , Statistics , Zarr using Dates axlist = [ RangeAxis ( \"time\" , Date ( \"2022-01-01\" ) : Day ( 1 ) : Date ( \"2022-01-30\" )), RangeAxis ( \"lon\" , range ( 1 , 10 , length = 10 )), RangeAxis ( \"lat\" , range ( 1 , 5 , length = 15 )), CategoricalAxis ( \"Variable\" , [ \"var1\" , \"var2\" ]) ] 4-element Vector{CubeAxis}: time Axis with 30 Elements from 2022-01-01 to 2022-01-30 lon Axis with 10 Elements from 1.0 to 10.0 lat Axis with 15 Elements from 1.0 to 5.0 Variable Axis with 2 elements: var1 var2 And the corresponding data data = rand ( 30 , 10 , 15 , 2 ) ds = YAXArray ( axlist , data ) c = ds [ Variable = \"var1\" ] # see OpenNetCDF to get the file mapslices ( mean \u2218 skipmissing , c , dims = \"Time\" ) YAXArray with the following dimensions lon Axis with 10 Elements from 1.0 to 10.0 lat Axis with 15 Elements from 1.0 to 5.0 Total size: 1.17 KB","title":"How to calculate a time mean"},{"location":"examples/generated/UserGuide/distributed/#distributed-calculations","text":"It is possible to distribute the calculations over multiple process. The following code does a time mean over all grid points using multiple CPU over a local machine. #using Distributed #addprocs(2) #@everywhere using Pkg #@everywhere Pkg.activate(\".\") #@everywhere begin using NetCDF using YAXArrays using Statistics using Zarr #end #@everywhere function mymean(output, pixel) @show \"doing a mean\" output[:] .= mean(pixel) #end #indims = InDims(\"time\") #outdims = OutDims() #resultcube = mapCube(mymean, c, indims=indims, outdims=outdims) In the last example, mapCube was used to map the mymean function. mapslices is a convenient function that can replace mapCube , where you can omit defining an extra function with the output argument as an input (e.g. mymean ). It is possible to simply use mapslice resultcube = mapslices ( mean \u2218 skipmissing , c , dims = \"time\" ) YAXArray with the following dimensions lon Axis with 10 Elements from 1.0 to 10.0 lat Axis with 15 Elements from 1.0 to 5.0 Total size: 1.17 KB","title":"Distributed calculations"},{"location":"examples/generated/UserGuide/distributed/#slurm-cluster","text":"It is also possible to distribute easily the workload on a cluster, with little modification to the code. The following code does a time mean over all grid points using multiple CPU over a SLURM cluster. To do so, we use the ClusterManagers package. #using Distributed #using ClusterManagers #addprocs(SlurmManager(10)) #@everywhere using Pkg #@everywhere Pkg.activate(\".\") #@everywhere using ESDL #@everywhere using Statistics #inpath=\"zg1000_AERday_CanESM5_esm-hist_r6i1p1f1_gn_18500101-20141231.nc\" #c = Cube(inpath, \"zg1000\") #resultcube = mapslices(mean \u2218 skipmissing, c, dims=\"time\") This page was generated using Literate.jl .","title":"SLURM cluster"},{"location":"examples/generated/UserGuide/openNetCDF/","text":"In this example we are going to use a NetCDF file but this should be very similar for other data backends. To open a single data file we first need to load the appropriate backend package via using NetCDF . using YAXArrays , NetCDF using Downloads url = \"https://www.unidata.ucar.edu/software/netcdf/examples/tos_O1_2001-2002.nc\" filename = Downloads . download ( url , \"tos_O1_2001-2002.nc\" ) # you pick your own path c = Cube ( filename ) YAXArray with the following dimensions lon Axis with 180 Elements from 1.0 to 359.0 lat Axis with 170 Elements from -79.5 to 89.5 time Axis with 24 Elements from CFTime.DateTime360Day(2001-01-16T00:00:00) to CFTime.DateTime360Day(2002-12-16T00:00:00) units: K name: tos Total size: 2.8 MB This page was generated using Literate.jl .","title":"Open NetCDF"},{"location":"examples/generated/UserGuide/openZarr/","text":"using Zarr , YAXArrays store = \"gs://cmip6/CMIP6/ScenarioMIP/DKRZ/MPI-ESM1-2-HR/ssp585/r1i1p1f1/3hr/tas/gn/v20190710/\" g = open_dataset ( zopen ( store , consolidated = true )) c = g [ \"tas\" ] YAXArray with the following dimensions lon Axis with 384 Elements from 0.0 to 359.0625 lat Axis with 192 Elements from -89.28422753251364 to 89.28422753251364 time Axis with 251288 Elements from 2015-01-01T03:00:00 to 2101-01-01T00:00:00 units: K name: tas Total size: 69.02 GB This page was generated using Literate.jl .","title":"Open Zarr (Store)"},{"location":"examples/generated/UserGuide/saving/","text":"Saving YAXArrays and Datasets \u00a4 Is possible to save datasets and YAXArray directly to zarr files. Saving a YAXArray to Zarr \u00a4 One can save any YAXArray using the savecube function. Simply add a path as an argument and the cube will be saved. using YAXArrays , Zarr a = YAXArray ( rand ( 10 , 20 )) f = tempname () savecube ( a , f , driver = :zarr ) YAXArray with the following dimensions Dim_1 Axis with 10 Elements from 1 to 10 Dim_2 Axis with 20 Elements from 1 to 20 Total size: 1.56 KB Saving a YAXArray to NetCDF \u00a4 Saving to NetCDF works exactly the same way. using YAXArrays , Zarr , NetCDF a = YAXArray ( rand ( 10 , 20 )) f = tempname () savecube ( a , f , driver = :netcdf ) YAXArray with the following dimensions Dim_1 Axis with 10 Elements from 1 to 10 Dim_2 Axis with 20 Elements from 1 to 20 Total size: 1.56 KB Saving a Dataset \u00a4 Saving Datasets can be done using the savedataset function. using YAXArrays , Zarr ds = Dataset ( x = YAXArray ( rand ( 10 , 20 )), y = YAXArray ( rand ( 10 ))); f = tempname (); savedataset ( ds , path = f , driver = :zarr ) YAXArray Dataset Dimensions: Dim_2 Axis with 20 Elements from 1 to 20 Dim_1 Axis with 10 Elements from 1 to 10 Variables: x y Overwriting a Dataset \u00a4 If a path already exists, an error will be thrown. Set overwrite=true to delete the existing dataset savedataset ( ds , path = f , driver = :zarr , overwrite = true ) YAXArray Dataset Dimensions: Dim_2 Axis with 20 Elements from 1 to 20 Dim_1 Axis with 10 Elements from 1 to 10 Variables: x y Appending to a Dataset \u00a4 New variables can be added to an existing dataset using the append=true keyword. ds2 = Dataset ( z = YAXArray ( rand ( 10 , 20 , 5 ))) savedataset ( ds2 , path = f , backend = :zarr , append = true ) open_dataset ( f , driver = :zarr ) YAXArray Dataset Dimensions: Dim_2 Axis with 20 Elements from 1 to 20 Dim_1 Axis with 10 Elements from 1 to 10 Dim_3 Axis with 5 Elements from 1 to 5 Variables: x z y Datacube Skeleton without the actual data \u00a4 Sometimes one merely wants to create a datacube \"Skeleton\" on disk and gradually fill it with data. Here we create YAXArray and write only the axis data and array metadata to disk, while no actual array data is copied: using YAXArrays , Zarr a = YAXArray ( zeros ( Union { Missing , Int32 }, 10 , 20 )) f = tempname (); r = savecube ( a , f , driver = :zarr , skeleton = true ); all ( ismissing , r [ : , : ]) true The skeleton argument is also available for savedataset . This page was generated using Literate.jl .","title":"Saving YAXArrays and Datasets"},{"location":"examples/generated/UserGuide/saving/#saving-yaxarrays-and-datasets","text":"Is possible to save datasets and YAXArray directly to zarr files.","title":"Saving YAXArrays and Datasets"},{"location":"examples/generated/UserGuide/saving/#saving-a-yaxarray-to-zarr","text":"One can save any YAXArray using the savecube function. Simply add a path as an argument and the cube will be saved. using YAXArrays , Zarr a = YAXArray ( rand ( 10 , 20 )) f = tempname () savecube ( a , f , driver = :zarr ) YAXArray with the following dimensions Dim_1 Axis with 10 Elements from 1 to 10 Dim_2 Axis with 20 Elements from 1 to 20 Total size: 1.56 KB","title":"Saving a YAXArray to Zarr"},{"location":"examples/generated/UserGuide/saving/#saving-a-yaxarray-to-netcdf","text":"Saving to NetCDF works exactly the same way. using YAXArrays , Zarr , NetCDF a = YAXArray ( rand ( 10 , 20 )) f = tempname () savecube ( a , f , driver = :netcdf ) YAXArray with the following dimensions Dim_1 Axis with 10 Elements from 1 to 10 Dim_2 Axis with 20 Elements from 1 to 20 Total size: 1.56 KB","title":"Saving a YAXArray to NetCDF"},{"location":"examples/generated/UserGuide/saving/#saving-a-dataset","text":"Saving Datasets can be done using the savedataset function. using YAXArrays , Zarr ds = Dataset ( x = YAXArray ( rand ( 10 , 20 )), y = YAXArray ( rand ( 10 ))); f = tempname (); savedataset ( ds , path = f , driver = :zarr ) YAXArray Dataset Dimensions: Dim_2 Axis with 20 Elements from 1 to 20 Dim_1 Axis with 10 Elements from 1 to 10 Variables: x y","title":"Saving a Dataset"},{"location":"examples/generated/UserGuide/saving/#overwriting-a-dataset","text":"If a path already exists, an error will be thrown. Set overwrite=true to delete the existing dataset savedataset ( ds , path = f , driver = :zarr , overwrite = true ) YAXArray Dataset Dimensions: Dim_2 Axis with 20 Elements from 1 to 20 Dim_1 Axis with 10 Elements from 1 to 10 Variables: x y","title":"Overwriting a Dataset"},{"location":"examples/generated/UserGuide/saving/#appending-to-a-dataset","text":"New variables can be added to an existing dataset using the append=true keyword. ds2 = Dataset ( z = YAXArray ( rand ( 10 , 20 , 5 ))) savedataset ( ds2 , path = f , backend = :zarr , append = true ) open_dataset ( f , driver = :zarr ) YAXArray Dataset Dimensions: Dim_2 Axis with 20 Elements from 1 to 20 Dim_1 Axis with 10 Elements from 1 to 10 Dim_3 Axis with 5 Elements from 1 to 5 Variables: x z y","title":"Appending to a Dataset"},{"location":"examples/generated/UserGuide/saving/#datacube-skeleton-without-the-actual-data","text":"Sometimes one merely wants to create a datacube \"Skeleton\" on disk and gradually fill it with data. Here we create YAXArray and write only the axis data and array metadata to disk, while no actual array data is copied: using YAXArrays , Zarr a = YAXArray ( zeros ( Union { Missing , Int32 }, 10 , 20 )) f = tempname (); r = savecube ( a , f , driver = :zarr , skeleton = true ); all ( ismissing , r [ : , : ]) true The skeleton argument is also available for savedataset . This page was generated using Literate.jl .","title":"Datacube Skeleton without the actual data"},{"location":"examples/generated/UserGuide/setchuncks/","text":"Set chunks \u00a4 To determine the chunk size of the array representation on disk, call the setchunks function prior to saving. Chunking YAXArrays \u00a4 using YAXArrays , Zarr a = YAXArray ( rand ( 10 , 20 )) a_chunked = setchunks ( a , ( 5 , 10 )) a_chunked . chunks 2\u00d72 DiskArrays.GridChunks{2}: (1:5, 1:10) (1:5, 11:20) (6:10, 1:10) (6:10, 11:20) And the saved file is also splitted into Chunks. f = tempname () savecube ( a_chunked , f , backend = :zarr ) Cube ( f ) . chunks 2\u00d72 DiskArrays.GridChunks{2}: (1:5, 1:10) (1:5, 11:20) (6:10, 1:10) (6:10, 11:20) Alternatively chunk sizes can be given by dimension name, so the following results in the same chunks: a_chunked = setchunks ( a , ( Dim_2 = 10 , Dim_1 = 5 )) a_chunked . chunks 2\u00d72 DiskArrays.GridChunks{2}: (1:5, 1:10) (1:5, 11:20) (6:10, 1:10) (6:10, 11:20) Chunking Datasets \u00a4 Set Chunks by Axis \u00a4 Set chunk size for each axis occuring in a dataset. This will be applied to all variables in the dataset: using YAXArrays , Zarr ds = Dataset ( x = YAXArray ( rand ( 10 , 20 )), y = YAXArray ( rand ( 10 )), z = YAXArray ( rand ( 10 , 20 , 5 ))) dschunked = setchunks ( ds , Dict ( \"Dim_1\" => 5 , \"Dim_2\" => 10 , \"Dim_3\" => 2 )) Cube ( dschunked ) . chunks 2\u00d72\u00d73 DiskArrays.GridChunks{3}: [:, :, 1] = (1:5, 1:10, 1:2) (1:5, 11:20, 1:2) (6:10, 1:10, 1:2) (6:10, 11:20, 1:2) [:, :, 2] = (1:5, 1:10, 3:4) (1:5, 11:20, 3:4) (6:10, 1:10, 3:4) (6:10, 11:20, 3:4) [:, :, 3] = (1:5, 1:10, 5:5) (1:5, 11:20, 5:5) (6:10, 1:10, 5:5) (6:10, 11:20, 5:5) Saving... f = tempname () savedataset ( dschunked , path = f , driver = :zarr ) YAXArray Dataset Dimensions: Dim_2 Axis with 20 Elements from 1 to 20 Dim_1 Axis with 10 Elements from 1 to 10 Dim_3 Axis with 5 Elements from 1 to 5 Variables: x y z Set chunking by Variable \u00a4 The following will set the chunk size for each Variable separately and results in exactly the same chunking as the example above using YAXArrays , Zarr ds = Dataset ( x = YAXArray ( rand ( 10 , 20 )), y = YAXArray ( rand ( 10 )), z = YAXArray ( rand ( 10 , 20 , 5 ))) dschunked = setchunks ( ds ,( x = ( 5 , 10 ), y = Dict ( \"Dim_1\" => 5 ), z = ( Dim_1 = 5 , Dim_2 = 10 , Dim_3 = 2 ))) Cube ( dschunked ) . chunks 2\u00d72\u00d73 DiskArrays.GridChunks{3}: [:, :, 1] = (1:5, 1:10, 1:2) (1:5, 11:20, 1:2) (6:10, 1:10, 1:2) (6:10, 11:20, 1:2) [:, :, 2] = (1:5, 1:10, 3:4) (1:5, 11:20, 3:4) (6:10, 1:10, 3:4) (6:10, 11:20, 3:4) [:, :, 3] = (1:5, 1:10, 5:5) (1:5, 11:20, 5:5) (6:10, 1:10, 5:5) (6:10, 11:20, 5:5) saving... f = tempname () savedataset ( dschunked , path = f , driver = :zarr ) YAXArray Dataset Dimensions: Dim_2 Axis with 20 Elements from 1 to 20 Dim_1 Axis with 10 Elements from 1 to 10 Dim_3 Axis with 5 Elements from 1 to 5 Variables: x y z Set chunking for all variables \u00a4 #The following code snippet only works when all member variables of the dataset have the same shape and sets the output chunks for all arrays. using YAXArrays , Zarr ds = Dataset ( x = YAXArray ( rand ( 10 , 20 )), y = YAXArray ( rand ( 10 , 20 )), z = YAXArray ( rand ( 10 , 20 ))) dschunked = setchunks ( ds ,( 5 , 10 )) Cube ( dschunked ) . chunks 2\u00d72\u00d73 DiskArrays.GridChunks{3}: [:, :, 1] = (1:5, 1:10, 1:1) (1:5, 11:20, 1:1) (6:10, 1:10, 1:1) (6:10, 11:20, 1:1) [:, :, 2] = (1:5, 1:10, 2:2) (1:5, 11:20, 2:2) (6:10, 1:10, 2:2) (6:10, 11:20, 2:2) [:, :, 3] = (1:5, 1:10, 3:3) (1:5, 11:20, 3:3) (6:10, 1:10, 3:3) (6:10, 11:20, 3:3) saving... f = tempname () savedataset ( dschunked , path = f , driver = :zarr ) YAXArray Dataset Dimensions: Dim_2 Axis with 20 Elements from 1 to 20 Dim_1 Axis with 10 Elements from 1 to 10 Variables: x y z This page was generated using Literate.jl .","title":"Setting chunks's size"},{"location":"examples/generated/UserGuide/setchuncks/#set-chunks","text":"To determine the chunk size of the array representation on disk, call the setchunks function prior to saving.","title":"Set chunks"},{"location":"examples/generated/UserGuide/setchuncks/#chunking-yaxarrays","text":"using YAXArrays , Zarr a = YAXArray ( rand ( 10 , 20 )) a_chunked = setchunks ( a , ( 5 , 10 )) a_chunked . chunks 2\u00d72 DiskArrays.GridChunks{2}: (1:5, 1:10) (1:5, 11:20) (6:10, 1:10) (6:10, 11:20) And the saved file is also splitted into Chunks. f = tempname () savecube ( a_chunked , f , backend = :zarr ) Cube ( f ) . chunks 2\u00d72 DiskArrays.GridChunks{2}: (1:5, 1:10) (1:5, 11:20) (6:10, 1:10) (6:10, 11:20) Alternatively chunk sizes can be given by dimension name, so the following results in the same chunks: a_chunked = setchunks ( a , ( Dim_2 = 10 , Dim_1 = 5 )) a_chunked . chunks 2\u00d72 DiskArrays.GridChunks{2}: (1:5, 1:10) (1:5, 11:20) (6:10, 1:10) (6:10, 11:20)","title":"Chunking YAXArrays"},{"location":"examples/generated/UserGuide/setchuncks/#chunking-datasets","text":"","title":"Chunking Datasets"},{"location":"examples/generated/UserGuide/setchuncks/#set-chunks-by-axis","text":"Set chunk size for each axis occuring in a dataset. This will be applied to all variables in the dataset: using YAXArrays , Zarr ds = Dataset ( x = YAXArray ( rand ( 10 , 20 )), y = YAXArray ( rand ( 10 )), z = YAXArray ( rand ( 10 , 20 , 5 ))) dschunked = setchunks ( ds , Dict ( \"Dim_1\" => 5 , \"Dim_2\" => 10 , \"Dim_3\" => 2 )) Cube ( dschunked ) . chunks 2\u00d72\u00d73 DiskArrays.GridChunks{3}: [:, :, 1] = (1:5, 1:10, 1:2) (1:5, 11:20, 1:2) (6:10, 1:10, 1:2) (6:10, 11:20, 1:2) [:, :, 2] = (1:5, 1:10, 3:4) (1:5, 11:20, 3:4) (6:10, 1:10, 3:4) (6:10, 11:20, 3:4) [:, :, 3] = (1:5, 1:10, 5:5) (1:5, 11:20, 5:5) (6:10, 1:10, 5:5) (6:10, 11:20, 5:5) Saving... f = tempname () savedataset ( dschunked , path = f , driver = :zarr ) YAXArray Dataset Dimensions: Dim_2 Axis with 20 Elements from 1 to 20 Dim_1 Axis with 10 Elements from 1 to 10 Dim_3 Axis with 5 Elements from 1 to 5 Variables: x y z","title":"Set Chunks by Axis"},{"location":"examples/generated/UserGuide/setchuncks/#set-chunking-by-variable","text":"The following will set the chunk size for each Variable separately and results in exactly the same chunking as the example above using YAXArrays , Zarr ds = Dataset ( x = YAXArray ( rand ( 10 , 20 )), y = YAXArray ( rand ( 10 )), z = YAXArray ( rand ( 10 , 20 , 5 ))) dschunked = setchunks ( ds ,( x = ( 5 , 10 ), y = Dict ( \"Dim_1\" => 5 ), z = ( Dim_1 = 5 , Dim_2 = 10 , Dim_3 = 2 ))) Cube ( dschunked ) . chunks 2\u00d72\u00d73 DiskArrays.GridChunks{3}: [:, :, 1] = (1:5, 1:10, 1:2) (1:5, 11:20, 1:2) (6:10, 1:10, 1:2) (6:10, 11:20, 1:2) [:, :, 2] = (1:5, 1:10, 3:4) (1:5, 11:20, 3:4) (6:10, 1:10, 3:4) (6:10, 11:20, 3:4) [:, :, 3] = (1:5, 1:10, 5:5) (1:5, 11:20, 5:5) (6:10, 1:10, 5:5) (6:10, 11:20, 5:5) saving... f = tempname () savedataset ( dschunked , path = f , driver = :zarr ) YAXArray Dataset Dimensions: Dim_2 Axis with 20 Elements from 1 to 20 Dim_1 Axis with 10 Elements from 1 to 10 Dim_3 Axis with 5 Elements from 1 to 5 Variables: x y z","title":"Set chunking by Variable"},{"location":"examples/generated/UserGuide/setchuncks/#set-chunking-for-all-variables","text":"#The following code snippet only works when all member variables of the dataset have the same shape and sets the output chunks for all arrays. using YAXArrays , Zarr ds = Dataset ( x = YAXArray ( rand ( 10 , 20 )), y = YAXArray ( rand ( 10 , 20 )), z = YAXArray ( rand ( 10 , 20 ))) dschunked = setchunks ( ds ,( 5 , 10 )) Cube ( dschunked ) . chunks 2\u00d72\u00d73 DiskArrays.GridChunks{3}: [:, :, 1] = (1:5, 1:10, 1:1) (1:5, 11:20, 1:1) (6:10, 1:10, 1:1) (6:10, 11:20, 1:1) [:, :, 2] = (1:5, 1:10, 2:2) (1:5, 11:20, 2:2) (6:10, 1:10, 2:2) (6:10, 11:20, 2:2) [:, :, 3] = (1:5, 1:10, 3:3) (1:5, 11:20, 3:3) (6:10, 1:10, 3:3) (6:10, 11:20, 3:3) saving... f = tempname () savedataset ( dschunked , path = f , driver = :zarr ) YAXArray Dataset Dimensions: Dim_2 Axis with 20 Elements from 1 to 20 Dim_1 Axis with 10 Elements from 1 to 10 Variables: x y z This page was generated using Literate.jl .","title":"Set chunking for all variables"},{"location":"tutorials/tutorial/","text":"YAXArray tutorial \u00a4 If you are interested in learning how to work with YAXArrays for different use cases you can follow along one of the following tutorials. Currently the overview tutorial is located at ESDLTutorials Repository You can find further tutorial videos at the EO College . Beware that the syntax in the video tutorials might be slightly changed. the other tutorials are still work in progress. General overview of the functionality of YAXArrays \u00a4 This tutorial provides a broad overview about the features of YAXArrays. Table-style iteration over YAXArrays \u00a4 Work in progress Sometimes you want to combine the data that is represented in the data cube with other datasets, which are best described as a data frame. In this tutorial you will learn how to use the Tables.jl interface to iterate over the data in the YAXArray. Combining multiple tiff files into a zarr based datacube \u00a4","title":"Tutorial"},{"location":"tutorials/tutorial/#yaxarray-tutorial","text":"If you are interested in learning how to work with YAXArrays for different use cases you can follow along one of the following tutorials. Currently the overview tutorial is located at ESDLTutorials Repository You can find further tutorial videos at the EO College . Beware that the syntax in the video tutorials might be slightly changed. the other tutorials are still work in progress.","title":"YAXArray tutorial"},{"location":"tutorials/tutorial/#general-overview-of-the-functionality-of-yaxarrays","text":"This tutorial provides a broad overview about the features of YAXArrays.","title":"General overview of the functionality of YAXArrays"},{"location":"tutorials/tutorial/#table-style-iteration-over-yaxarrays","text":"Work in progress Sometimes you want to combine the data that is represented in the data cube with other datasets, which are best described as a data frame. In this tutorial you will learn how to use the Tables.jl interface to iterate over the data in the YAXArray.","title":"Table-style iteration over YAXArrays"},{"location":"tutorials/tutorial/#combining-multiple-tiff-files-into-a-zarr-based-datacube","text":"","title":"Combining multiple tiff files into a zarr based datacube"}]}