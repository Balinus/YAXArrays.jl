var documenterSearchIndex = {"docs":
[{"location":"man/yaxarrays/#The-YAXArray-Data-Type","page":"-","title":"The YAXArray Data Type","text":"","category":"section"},{"location":"api/#Public-API","page":"Docstring Reference","title":"Public API","text":"","category":"section"},{"location":"api/","page":"Docstring Reference","title":"Docstring Reference","text":"DocTestSetup= quote\nusing YAXArrays\nend","category":"page"},{"location":"api/","page":"Docstring Reference","title":"Docstring Reference","text":"Modules = [YAXArrays, YAXArrays.Cubes, YAXArrays.Cubes.Axes, YAXArrays.DAT, YAXArrays.DAT.SentinelMissings, YAXArrays.Datasets,YAXArrays.YAXTools]\nPrivate = false","category":"page"},{"location":"api/#YAXArrays.Cubes","page":"Docstring Reference","title":"YAXArrays.Cubes","text":"The functions provided by YAXArrays are supposed to work on different types of cubes. This module defines the interface for all Data types that\n\n\n\n\n\n","category":"module"},{"location":"api/#YAXArrays.Cubes.YAXArray","page":"Docstring Reference","title":"YAXArrays.Cubes.YAXArray","text":"YAXArray{T,N}\n\nAn array labelled with named axes that have values associated with them. It can wrap normal arrays or, more typically DiskArrays.\n\nFields\n\naxes a Vector{CubeAxis} containing the Axes of the Cube\ndata N-D array containing the data\n\n\n\n\n\n","category":"type"},{"location":"api/#YAXArrays.Cubes.caxes","page":"Docstring Reference","title":"YAXArrays.Cubes.caxes","text":"Returns the axes of a Cube\n\n\n\n\n\n","category":"function"},{"location":"api/#YAXArrays.Cubes.concatenatecubes-Tuple{Any, CubeAxis}","page":"Docstring Reference","title":"YAXArrays.Cubes.concatenatecubes","text":"function concatenateCubes(cubelist, cataxis::CategoricalAxis)\n\nConcatenates a vector of datacubes that have identical axes to a new single cube along the new axis cataxis\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.Cubes.readcubedata-Tuple{Any}","page":"Docstring Reference","title":"YAXArrays.Cubes.readcubedata","text":"readcubedata(cube)\n\nGiven any array implementing the YAXArray interface it returns an in-memory YAXArray from it.\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.Cubes.subsetcube","page":"Docstring Reference","title":"YAXArrays.Cubes.subsetcube","text":"This function calculates a subset of a cube's data\n\n\n\n\n\n","category":"function"},{"location":"api/#YAXArrays.Cubes.Axes.CategoricalAxis","page":"Docstring Reference","title":"YAXArrays.Cubes.Axes.CategoricalAxis","text":"CategoricalAxis{T,S}\n\nTo represent axes that are categorical, where T is the element type. The type parameter S denotes the axis name (a symbol). The default constructor is:\n\nCategoricalAxis(axname::String,values::Vector{T})\n\n\n\n\n\n","category":"type"},{"location":"api/#YAXArrays.Cubes.Axes.CubeAxis","page":"Docstring Reference","title":"YAXArrays.Cubes.Axes.CubeAxis","text":"abstract CubeAxis{T}\n\nSupertype of all axes. Every CubeAxis is an 1D Cube itself and can be passed to mapCube operations.\n\n\n\n\n\n","category":"type"},{"location":"api/#YAXArrays.Cubes.Axes.RangeAxis-Union{Tuple{T}, Tuple{Symbol, AbstractVector{T}}} where T","page":"Docstring Reference","title":"YAXArrays.Cubes.Axes.RangeAxis","text":"RangeAxis{T,S,R}\n\nTo represent axes that are categorical, where T is the element type. The type parameter S denotes the axis name (a symbol) and R the type of the range which is used to represent the axis values. The default constructor is:\n\nRangeAxis(axname::String,values::Range{T})\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.Cubes.Axes.getAxis-Tuple{Any, Any}","page":"Docstring Reference","title":"YAXArrays.Cubes.Axes.getAxis","text":"getAxis(desc::String, c)\n\nGiven the string of an axis name and a cube, returns this axis of the cube.\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.DAT.InDims","page":"Docstring Reference","title":"YAXArrays.DAT.InDims","text":"InDims(axisdesc...;...)\n\nCreates a description of an Input Data Cube for cube operations. Takes a single   or multiple axis descriptions as first arguments. Alternatively a MovingWindow(@ref) struct can be passed to include   neighbour slices of one or more axes in the computation.    Axes can be specified by their   name (String), through an Axis type, or by passing a concrete axis.\n\nKeyword arguments\n\nartype how shall the array be represented in the inner function. Defaults to Array, alternatives are DataFrame or AsAxisArray\nfilter define some filter to skip the computation, e.g. when all values are missing. Defaults to   AllMissing(), possible values are AnyMissing(), AnyOcean(), StdZero(), NValid(n)   (for at least n non-missing elements). It is also possible to provide a custom one-argument function   that takes the array and returns true if the compuation shall be skipped and false otherwise.\nwindow_oob_value if one of the input dimensions is a MowingWindow, this value will be used to fill out-of-bounds areas\n\n\n\n\n\n","category":"type"},{"location":"api/#YAXArrays.DAT.MovingWindow","page":"Docstring Reference","title":"YAXArrays.DAT.MovingWindow","text":"MovingWindow(desc, pre, after)\n\nConstructs a MovingWindow object to be passed to an InDims constructor to define that the axis in desc shall participate in the inner function (i.e. shall be looped over), but inside the inner function pre values before and after values after the center value will be passed as well. \n\nFor example passing MovingWindow(\"Time\", 2, 0) will loop over the time axis and  always pass the current time step plus the 2 previous steps. So in the inner function the array will have an additional dimension of size 3.    \n\n\n\n\n\n","category":"type"},{"location":"api/#YAXArrays.DAT.OutDims-Tuple","page":"Docstring Reference","title":"YAXArrays.DAT.OutDims","text":"OutDims(axisdesc;...)\n\nCreates a description of an Output Data Cube for cube operations. Takes a single   or a Vector/Tuple of axes as first argument. Axes can be specified by their   name (String), through an Axis type, or by passing a concrete axis.\n\naxisdesc: List of input axis names\nbackend : specifies the dataset backend to write data to, must be either :auto or a key in YAXArrayBase.backendlist\nupdate : specifies wether the function operates inplace or if an output is returned\nartype : specifies the Array type inside the inner function that is mapped over\nchunksize: A Dict specifying the chunksizes for the output dimensions of the cube, or :input to copy chunksizes from input cube axes or :max to not chunk the inner dimensions\nouttype: force the output type to a specific type, defaults to Any which means that the element type of the first input cube is used\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.DAT.CubeTable-Tuple{}","page":"Docstring Reference","title":"YAXArrays.DAT.CubeTable","text":"CubeTable()\n\nFunction to turn a DataCube object into an iterable table. Takes a list of as arguments, specified as a name=cube expression. For example CubeTable(data=cube1,country=cube2) would generate a Table with the entries data and country, where data contains the values of cube1 and country the values of cube2. The cubes are matched and broadcasted along their axes like in mapCube.\n\nIn addition, one can specify include_axes=(ax1,ax2...) when one wants to include the values of certain axes in the table. For example the command (CubeTable(tair=cube1 axes=(\"lon\",\"lat\",\"time\")) would produce an iterator over a data structure with entries tair, lon, lat and time.\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.DAT.cubefittable-Tuple{Any, Any, Any}","page":"Docstring Reference","title":"YAXArrays.DAT.cubefittable","text":"cubefittable(tab,o,fitsym;post=getpostfunction(o),kwargs...)\n\nExecutes fittable on the @CubeTable tab with the (Weighted-)OnlineStat o, looping through the values specified by fitsym. Finally, writes the results from the TableAggregator to an output data cube.\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.DAT.fittable-Tuple{Any, Any, Any}","page":"Docstring Reference","title":"YAXArrays.DAT.fittable","text":"fittable(tab,o,fitsym;by=(),weight=nothing)\n\nLoops through an iterable table tab and thereby fitting an OnlineStat o with the values specified through fitsym. Optionally one can specify a field (or tuple) to group by. Any groupby specifier can either be a symbol denoting the entry to group by or an anynymous function calculating the group from a table row.\n\nFor example the following would caluclate a weighted mean over a cube weighted by grid cell area and grouped by country and month:\n\nfittable(iter,WeightedMean,:tair,weight=(i->abs(cosd(i.lat))),by=(i->month(i.time),:country))\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.DAT.mapCube-Tuple{Function, Tuple, Vararg{Any, N} where N}","page":"Docstring Reference","title":"YAXArrays.DAT.mapCube","text":"mapCube(fun, cube, addargs...;kwargs)\n\nMap a given function fun over slices of the data cube cube.\n\nKeyword arguments\n\nmax_cache=1e7 maximum size of blocks that are read into memory, defaults to approx 10Mb\nindims::InDims List of input cube descriptors of type InDims for each input data cube\noutdims::OutDims List of output cube descriptors of type OutDims for each output cube\ninplace does the function write to an output array inplace or return a single value> defaults to true\nispar boolean to determine if parallelisation should be applied, defaults to true if workers are available.\nshowprog boolean indicating if a ProgressMeter shall be shown\ninclude_loopvars boolean to indicate if the varoables looped over should be added as function arguments\nloopchunksize determines the chunk sizes of variables which are looped over, a dict\nkwargs additional keyword arguments passed to the inner function\n\nThe first argument is always the function to be applied, the second is the input cube or a tuple input cubes if needed.\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.DAT.savecube-Tuple{Any, AbstractString}","page":"Docstring Reference","title":"YAXArrays.DAT.savecube","text":"savecube(cube,name::String)\n\nSave a YAXArray to the folder name in the YAXArray working directory.\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.DAT.SentinelMissings.as_sentinel-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Any}} where T<:Number","page":"Docstring Reference","title":"YAXArrays.DAT.SentinelMissings.as_sentinel","text":"as_sentinel(x, v)\n\nReinterprets a Number Array or a Number x so that values in x that equal v will be treated as missing. This is done by reinterpreting the array as a SentinelMissing without copying the data.\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.YAXTools.@loadOrGenerate-Tuple","page":"Docstring Reference","title":"YAXArrays.YAXTools.@loadOrGenerate","text":"macro loadOrGenerate(x...,expression)\n\nTakes a list of variablename=>\"Storage Name\" pairs. Checks if all datasets can be found on disk and loads them. If not, the datasets will be regenerated by evaluating the given expression.\n\nTo force recalculation, call YAXArrays.recalculate(true) before evaluating the macro.\n\nExample\n\nThe following lines will check if cubes with the names \"Filled\" and \"Normalized\" exist on disk, load them and assign the variable names cube_filled and cube_norm. If the datasets to not exist on disk, they are generated and saved under the given names.\n\n    @loadOrGenerate cube_filled=>\"Filled\" cube_norm=>\"Normalized\" begin\n    cube_norm   = mapCube(normalize_TS,d)\nend  \n\n\n\n\n\n","category":"macro"},{"location":"api/#Internal-API","page":"Docstring Reference","title":"Internal API","text":"","category":"section"},{"location":"api/","page":"Docstring Reference","title":"Docstring Reference","text":"Modules = [YAXArrays, YAXArrays.Cubes, YAXArrays.Cubes.Axes, YAXArrays.DAT, YAXArrays.DAT.SentinelMissings,YAXArrays.Datasets,YAXArrays.YAXTools]\nPublic = false","category":"page"},{"location":"api/#YAXArrays.Cubes.Axes.axcopy-Tuple{RangeAxis, Any}","page":"Docstring Reference","title":"YAXArrays.Cubes.Axes.axcopy","text":"axcopy(x,vals)\n\nMakes a copy of a CubeAxis with the values vals\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.Cubes.Axes.findAxis-Tuple{Any, Any}","page":"Docstring Reference","title":"YAXArrays.Cubes.Axes.findAxis","text":"Fallback method\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.DAT.DATConfig","page":"Docstring Reference","title":"YAXArrays.DAT.DATConfig","text":"Configuration object of a DAT process. This holds all necessary information to perform the calculations. It contains the following fields:\n\nincubes::NTuple{NIN,InputCube} The input data cubes\noutcube::NTuple{NOUT,OutputCube} The output data cubes\n\nallInAxes     :: Vector LoopAxes      :: Vector ispar         :: Bool loopcachesize :: Vector{Int} maxcache fu inplace      :: Bool includeloopvars:: Bool ntr addargs kwargs\n\n\n\n\n\n","category":"type"},{"location":"api/#YAXArrays.DAT.InputCube","page":"Docstring Reference","title":"YAXArrays.DAT.InputCube","text":"Internal representation of an input cube for DAT operations\n\n\n\n\n\n","category":"type"},{"location":"api/#YAXArrays.DAT.OutputCube","page":"Docstring Reference","title":"YAXArrays.DAT.OutputCube","text":"Internal representation of an output cube for DAT operations\n\n\n\n\n\n","category":"type"},{"location":"api/#YAXArrays.DAT.cmpcachmisses-Tuple{Any, Any}","page":"Docstring Reference","title":"YAXArrays.DAT.cmpcachmisses","text":"Function that compares two cache miss specifiers by their importance\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.DAT.getFrontPerm-Tuple{Any, Any}","page":"Docstring Reference","title":"YAXArrays.DAT.getFrontPerm","text":"Calculate an axis permutation that brings the wanted dimensions to the front\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.DAT.getLoopCacheSize-NTuple{5, Any}","page":"Docstring Reference","title":"YAXArrays.DAT.getLoopCacheSize","text":"Calculate optimal Cache size to DAT operation\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.Datasets.createdataset-Tuple{Any, Any}","page":"Docstring Reference","title":"YAXArrays.Datasets.createdataset","text":"function createdataset(DS::Type,axlist; kwargs...)\n\nCreates a new datacube with axes specified in axlist. Each axis must be a subtype   of CubeAxis. A new empty Zarr array will be created and can serve as a sink for   mapCube operations.\n\nKeyword arguments\n\nfolder=tempname() location where the new cube is stored\nT=Union{Float32,Missing} data type of the target cube\nchunksize = ntuple(i->length(axlist[i]),length(axlist)) chunk sizes of the array\nchunkoffset = ntuple(i->0,length(axlist)) offsets of the chunks\npersist::Bool=true shall the disk data be garbage-collected when the cube goes out of scope?\noverwrite::Bool=false overwrite cube if it already exists\nproperties=Dict{String,Any}() additional cube properties\nfillvalue= T>:Missing ? defaultfillval(Base.nonmissingtype(T)) : nothing fill value\ndatasetaxis=\"Variable\" special treatment of a categorical axis that gets written into separate zarr arrays\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/#YAXArrays.Datasets.testrange-Tuple{Any}","page":"Docstring Reference","title":"YAXArrays.Datasets.testrange","text":"Test if data in x can be approximated by a step range\n\n\n\n\n\n","category":"method"},{"location":"man/datasets/#YAXArray-Datasets","page":"-","title":"YAXArray Datasets","text":"","category":"section"},{"location":"examples/Time Mean/#How-to-calculate-a-time-mean","page":"Time Mean","title":"How to calculate a time mean","text":"","category":"section"},{"location":"examples/Time Mean/","page":"Time Mean","title":"Time Mean","text":"using ESDL\nc = Cube()\ncitaly = c[var = [\"air_temperature_2m\", \"evaporation\"], region=\"Italy\", time=2001:2003]\nmapslices(mean ∘ skipmissing, c, dims=\"Time\")","category":"page"},{"location":"examples/Time Mean/#Distributed-calculations","page":"Time Mean","title":"Distributed calculations","text":"","category":"section"},{"location":"examples/Time Mean/#Local-machine","page":"Time Mean","title":"Local machine","text":"","category":"section"},{"location":"examples/Time Mean/","page":"Time Mean","title":"Time Mean","text":"It is possible to distribute the calculations over multiple process. The following code does a time mean over all grid points using multiple CPU over a local machine.","category":"page"},{"location":"examples/Time Mean/","page":"Time Mean","title":"Time Mean","text":"using Distributed\naddprocs(2)\n\n@everywhere using Pkg\n@everywhere Pkg.activate(\".\")\n@everywhere using ESDL\n@everywhere using Statistics\n\n@everywhere function mymean(output, pixel)\n       output = mean(pixel)\nend\n\nc = Cube()\ntair = subsetcube(c,variable=\"air_temperature_2m\", time=2001:2016)\ntair_c = map(t->t-273.15, tair)\n\nindims = InDims(TimeAxis)\noutdims = OutDims()\n\nresultcube = mapCube(mymean, tair_c, indims=indims, outdims=outdims)","category":"page"},{"location":"examples/Time Mean/","page":"Time Mean","title":"Time Mean","text":"In the last example, mapCube was used to map the mymean function. mapslices is a convenient function that can replace mapCube, where you can omit defining an extra function with the output argument as an input (e.g. mymean). It is possible to simply use mapslice","category":"page"},{"location":"examples/Time Mean/","page":"Time Mean","title":"Time Mean","text":"resultcube = mapslices(mean ∘ skipmissing, c, dims=\"time\")","category":"page"},{"location":"examples/Time Mean/#SLURM-cluster","page":"Time Mean","title":"SLURM cluster","text":"","category":"section"},{"location":"examples/Time Mean/","page":"Time Mean","title":"Time Mean","text":"It is also possible to distribute easily the workload on a cluster, with little modification to the code. The following code does a time mean over all grid points using multiple CPU over a SLURM cluster. To do so, we use the ClusterManagers package.","category":"page"},{"location":"examples/Time Mean/","page":"Time Mean","title":"Time Mean","text":"using Distributed\nusing ClusterManagers\n\naddprocs(SlurmManager(10))\n\n@everywhere using Pkg\n@everywhere Pkg.activate(\".\")\n@everywhere using ESDL\n@everywhere using Statistics\n\ninpath=\"zg1000_AERday_CanESM5_esm-hist_r6i1p1f1_gn_18500101-20141231.nc\"\n\nc = Cube(inpath, \"zg1000\")\n\nresultcube = mapslices(mean ∘ skipmissing, c, dims=\"time\")","category":"page"},{"location":"man/iterators/#Table-style-iteration-over-YAXArrays","page":"Table-style iteration over YAXArrays","title":"Table-style iteration over YAXArrays","text":"","category":"section"},{"location":"man/applying functions/#Mapping-functions-over-YAXArrays","page":"Mapping functions over YAXArrays","title":"Mapping functions over YAXArrays","text":"","category":"section"},{"location":"#YAXArrays.jl","page":"Home","title":"YAXArrays.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Yet another xarray-like Julia package","category":"page"},{"location":"","page":"Home","title":"Home","text":"A package for operating on out-of-core labeled arrays, based on stores like NetCDF or Zarr.  ","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"open datasets from a variety of sources (NetCDF, Zarr, ArchGDAL)\ninteroperability with other named axis packages through YAXArrayBase\nefficient mapslices operations on huge multiple arrays, optimized for high-latency data access (object storage, compressed datasets) ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The YAXArray tutorial provides a tutorial explaining how to get started using YAXArrays.","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"man/tutorial.md\",\n    \"man/datasets.md\",\n    \"man/yaxarrays.md\",\n    \"man/applying function.md\",\n    \"man/iteratirs.md\",\n    \"examples/examples.md\",\n]\nDepth = 2","category":"page"},{"location":"","page":"Home","title":"Home","text":"<!– ","category":"page"},{"location":"#Library-Outline","page":"Home","title":"Library Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"lib/public.md\", \"lib/internals.md\"]","category":"page"},{"location":"#main-index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"lib/public.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"–>","category":"page"},{"location":"man/tutorial/#YAXArray-tutorial","page":"Tutorial","title":"YAXArray tutorial","text":"","category":"section"}]
}
